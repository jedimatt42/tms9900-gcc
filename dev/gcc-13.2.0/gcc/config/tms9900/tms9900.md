;;- Machine description for the tms9900 for GNU C compiler
;; Copyright (C) 2010-2023 Free Software Foundation, Inc.
;; Contributed by Eric Welser and Mark Burkley (mark@burkley.net)

;; Copyright 2009 Eric Welser (EMW)
;; Copyright 2023 Mark Burkley (MGB)

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; MGB NOTES
;;    - rtx notation is insn(dst,src) but tms asm notation is <op> src,dst so
;;      beware of operand ordering
;;    - all byte (QI) ops need to have expands to cater for the fact that in
;;      TMS9900 a 16-bit operation can't be done on a reg that contains an 8-bit value
;;      unless it has been shifted by 8
;;    - Many byte insns are restricted to registers only as TMS9900 doesn't have
;;      byte version of abs, neg, etc.
;;    - Insns like exend, trunc, abs, etc, are done in place but passed two
;;      distinct params.  This is ok, the compiler is forced to move src and dst to the
;;      same reg by the "0" constraint.
;;    - optimiser doesn't understand opcodes, just insns.  So keep insns as
;;      short as possible.  One opcode preferable, two max.  Any more, use an expand instead
;;    - 32-bit arith insns have been moved to C code.  Emitting lengthy opcode
;;      sequences shouldn't be part of a md file.

(include "constraints.md")
(include "defines.md")
(include "predicates.md")

;;-------------------------------------------------------------------
;;  Function Calls
;;-------------------------------------------------------------------

; declaring a call clobbers R11 looks cool but we've never needed it before and
; I susp[ect it may be causing a segfault in emi_call_1 when last_call_insn can't
; find this insn
;   (clobber (reg:HI CALL_RETURN_REGNUM))
; ditto for use
; (use (match_operand 2 ""))
;
;  calls and sibcalls are sep insns so no need to check any more:
;    if(SIBLING_CALL_P(insn))
;      output_asm_insn("b    %0", operands);
;    else

;;-------------------------------------------------------------------
;; Jump to a subroutine which returns a value
(define_insn "call"
  [(call (match_operand:HI 0 "general_operand" "rR,Q")
         (match_operand:HI 1 "general_operand"  "g,g"))
  ]
  ""
  {
    tms9900_debug_operands ("call", operands, 2);
    return ("bl   %0");
  }
  [(set_attr "length" "2,4")]
)


;-------------------------------------------------------------------
; Jump to a subroutine which returns a value
;   (clobber (reg:HI CALL_RETURN_REGNUM))
;   (use (match_operand 3 ""))
;
;  Define as an expand of gen_call causes a segfault in emit-rtl.cc as the insn
; is not emitted as a call_insn.  Changing back to define_insn even though this
; does create some repitition

(define_insn "call_value"
  [(set (match_operand 0 "" "")
        (call (match_operand:HI 1 "general_operand" "rR,Q")
              (match_operand:HI 2 "general_operand" "g,g")))
  ]
  ""
  {
    tms9900_debug_operands ("call_value", operands, 3);
    return("bl   %1");
  }
  [(set_attr "length" "2,4")]
)

; Define sibcalls as expands for indirect jump (branch).  We don't care about
; return values - no action needed from us.
;   (use (match_operand 2 ""))
(define_insn "sibcall"
  [(call (match_operand:HI 0 "general_operand" "rR,Q")
         (match_operand:HI 1 "general_operand"  "g,g"))
  ]
  ""
  {
    tms9900_debug_operands ("sibcall", operands, 2);
    return("b    %0");
  }
  [(set_attr "length" "2,4")]
)

;   (use (match_operand 3 ""))
(define_insn "sibcall_value"
  [(set (match_operand 0 "" "")
        (call (match_operand:HI 1 "general_operand" "rR,Q")
              (match_operand:HI 2 "general_operand" "g,g")))
  ]
  ""
  {
    tms9900_debug_operands ("sibcall_value", operands, 3);
    return("b    %1");
  }
  [(set_attr "length" "2,4")]
)


;;-------------------------------------------------------------------
;; Define function prologue
(define_expand "prologue"
  [(const_int 0)]
  ""
{
  tms9900_expand_prologue();
  DONE;
})


;;-------------------------------------------------------------------
;; Define function epilogue
(define_expand "epilogue"
  [(return)]
  ""
{
  tms9900_expand_epilogue(false);
  DONE;
})

(define_expand "sibcall_epilogue"
  [(return)]
  ""
{
  tms9900_expand_epilogue(true);
  DONE;
})


;;-------------------------------------------------------------------
;; Define function return
(define_insn "*rt"
  [(unspec [(match_operand:HI 0 "general_operand" "")] UNSPEC_RETURN)]
  ""
  "b    *r11"
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Comparison Instructions
;;-------------------------------------------------------------------

;; TODO cc0 deprecated https://gcc.gnu.org/wiki/CC0Transition
;; find-and-replace cc0 with reg:CC ST_REGNUM for now

;; cmp to zero is done explicitly or implicitly so can just do a mov to self to
;; compare.  BUT if self is a ROM target then that could invoke unintended side
;; effects like bank switching, so mov to temp reg r0 instead.  This also saves
;; 2 bytes for mem label compares.
(define_insn "tmps9900_cmp<mode>_zero"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QHint 0 "nonimmediate_operand" "rR,Q")
                    (const_int 0)))]
  ""
  {
    tms9900_debug_operands ("cmp<mode>_zero", operands, 1);
    return("mov<QHint:isfx> %0, r0");
  }
  [(set_attr "length" "2,4")])

(define_insn "tms9900_cmpqi"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 0 "nonimmediate_operand" "rR,rR,Q, Q,rR,Q")
                    (match_operand:QI 1 "general_operand"      "rR,Q, rR,Q,i ,i")))]
  ""
  {
    tms9900_debug_operands ("tms9900_cmpqi", operands, 2);

    if (which_alternative >= 4)
    {
      if (INTVAL (operands[1]) == 0)
      {
        printf ("why didn't you call tstqi?\n");
        gcc_unreachable();
      }

      int val = (INTVAL(operands[1]) & 0xff) << 8;
      operands[1] = GEN_INT(val);
      output_asm_insn ("li   r0, %1", operands);
      output_asm_insn ("cb   %0, r0", operands);
    }
    else
      output_asm_insn ("cb   %0, %1", operands);

    return "";
  }
  [(set_attr "length" "2,4,4,6,6,8")])


; Define an empty insn for cmpqi and cmphi as these are (mandatory) (I don't
; think they are in gcc13).  The actual
; emit will come from a post reload insn that clobbers CC
; "length" is defined even though this pattern won't appear at
; assembly language output time.  But the length is used by
; tms9900_insn_cost, before the post-reload splitter adds the
; CC clobber to the insn.
; (define_insn "cmp<mode>"
;   [(set (match_operand:QHint 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r, r")
;         (match_operand:QHint 1 "general_operand"       "rR>,Q,  rR>,Q,OM,i"))]
;   ""
;   ""
;   [(set_attr "length" "2,4,4,6,2,4")])
;;-------------------------------------

; TEST if the clobber that breaks the match - nope
; TEST if needs reload_compelted - nope
; TEST if operands must match split - nope
; TEST if expand and then insn works - yes!

;: Define an insn that compares a byte by loading into r0 first and then doing a
;; byte compare.  Note we can't ask for a clobber since this insn will be emitted
;; post reload.  We can use r0 as it is never used as a general reg.

(define_insn "tms9900_cmphi"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:HI 0 "nonimmediate_operand" "rR,rR,Q, Q,r,R,Q")
                    (match_operand:HI 1 "general_operand"      "rR,Q, rR,Q,i,i,i")))]
  ""
  {
    tms9900_debug_operands ("cmpqi", operands, 2);

    if (which_alternative == 4)
    {
      if (INTVAL (operands[1]) == 0)
      {
        printf ("why didn't you call tsthi?\n");
        gcc_unreachable();
      }
      output_asm_insn ("ci   %0, %1", operands);
    }
    else if (which_alternative >= 5)
    {
      output_asm_insn ("li   r0, %1", operands);
      output_asm_insn ("c    %0, r0", operands);
    }
    else
      output_asm_insn ("c    %0, %1", operands);

    return "";
  }
  [(set_attr "length" "2,4,4,6,4,6,8")])

;; All MOV instructions in tms9900 set condition flags by doing implicit
;; compare to zero.  TODO Do we need a CCNZmode?

;;-------------------------------------------------------------------
;;  Move Operations
;;-------------------------------------------------------------------

; Define an empty insn for movqi and movhi as these are mandatory.  The actual
; emit will come from a post reload insn that clobbers CC
; "length" is defined even though this pattern won't appear at
; assembly language output time.  But the length is used by
; tms9900_insn_cost, before the post-reload splitter adds the
; CC clobber to the insn.
(define_insn "mov<mode>"
  [(set (match_operand:QHint 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r, r")
        (match_operand:QHint 1 "general_operand"       "rR>,Q,  rR>,Q,OM,i"))]
  ""
  ""
  [(set_attr "length" "2,4,4,6,2,4")])

; What does this do?  Define all setters as clobberCC after reload??

;; This splits all the integer moves: DI and SI modes as well as
;; the simple machine operations.
(define_split
  [(set (match_operand:QHint 0 "nonimmediate_operand" "")
        (match_operand:QHint 1 "general_operand" ""))]
  "reload_completed"
  [(parallel [(set (match_dup 0) (match_dup 1))
              (clobber (reg:CC CC_REGNUM))])]
  "")

; TEST - if these are defined early on, then they will match before a more
; general const mov
; TODO this is wrong for bytes
(define_insn "*tms9900_mov<mode>_zero"
  [(set (match_operand:QHint 0 "nonimmediate_operand" "=rR>,Q")
        (const_int 0))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "clr  %0"
  [(set_attr "length" "2,4")])

(define_insn "*tms9900_mov<mode>_minus_one"
  [(set (match_operand:QHint 0 "nonimmediate_operand" "=rR>,Q")
        (const_int -1))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "seto %0"
  [(set_attr "length" "2,4")])

(define_insn "tms9900_movhi_const"
  [(set (match_operand:HI 0 "register_operand"  "=r")
        (match_operand:HI 1 "immediate_operand" "i"))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "li   %0, %1"
  [(set_attr "length" "4")])

(define_insn "tms9900_movqi_const"
  [(set (match_operand:QI 0 "register_operand"  "=r")
        (match_operand:QI 1 "immediate_operand" "i"))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    int val = INTVAL(operands[1]) << 8;
    operands[1] = GEN_INT(val);
    return "li   %0, %1";
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Move byte value


;  I don't really know what this does but I think it is needed since the actual
;  insns will all be movhi_cc, movhi_nocc, etc.

; (define_expand "mov<mode>"
;   [(set (match_operand:QHint 0 "nonimmediate_operand" "")
;         (match_operand:QHint 1 "general_operand"       ""))]
;   ""
;   "")

;;-------------------------------------------------------------------
;; Move one or two-byte value

(define_insn "mov<mode><cc_cc>"
  [(set (match_operand:QHint 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q")
        (match_operand:QHint 1 "general_operand"      "rR>, Q,  rR>,Q"))
   (clobber (reg:CC CC_REGNUM))]
  "reload_completed"
  {
    tms9900_debug_operands ("mov<mode>", operands, 2);
    tms9900_inline_debug ("; mov<mode> alt=%d\n", which_alternative);
    #if 0
    if (which_alternative >= 4)
    {
      int val = INTVAL(operands[1]);

      // TODO by emitting either a 2-byte or 4-byte opcode for the same
      // alternative we are breaking the length attribute at the end.  This
      // doesn't seem to matter.  Does this mean length is not even needed?

      // TODO adding constraints OM before i works to capture consts we can
      // reduce

      if (val == 0)
        return("clr  %0");
      else if (val == 0xffff)
        return("seto %0");
      else
        return("li   %0, %1");
    }
    else
    #endif
    {
      return("mov<QHint:isfx> %1, %0");
    }
  }
  [(set_attr "length" "2,4,4,6")])

;;-------------------------------------------------------------------
;; Move four-byte value as two 2-byte regs.  If immediate, emit two movhi insns
;; with high and low part of constants.  Constraints O and M are allowed so we
;; can issue seto or clr for -1 and 0 respectively
;;
;; Changed this from an expand back to an insn - it would be better as an expand
;; if that could be made to work
;;-------------------------------------------------------------------
(define_insn "movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r")
        (match_operand:SI 1 "general_operand" "rR>,Q,rR>,Q,i"))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("movsi", operands, 2);
    tms9900_inline_debug ("; movsi alt=%d\n", which_alternative);

    rtx args[4];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);

    if (which_alternative >= 4)
    {
      args[2] = gen_rtx_CONST_INT (HImode, ((UINTVAL(operands[1])&0xffff0000)>>16));
      args[3] = gen_rtx_CONST_INT (HImode, (UINTVAL(operands[1])&0xffff));
      tms9900_inline_debug ("; movsi op1=%08X hi=%04X lo=%04X\n",
                            INTVAL (operands[1]),
                            INTVAL (args[2]),
                            INTVAL (args[3]));

      if (INTVAL(args[2]) == 0xffff)
        output_asm_insn("seto %0", args);
      else if (INTVAL(args[2]) == 0)
        output_asm_insn("clr  %0", args);
      else
        output_asm_insn("li   %0, %2", args);

      if (INTVAL(args[3]) == 0xffff)
        output_asm_insn("seto %1", args);
      else if (INTVAL(args[3]) == 0)
        output_asm_insn("clr  %1", args);
      else
        output_asm_insn("li   %1, %3", args);
    }
    else
    {
      args[2] = gen_highpart (HImode, operands[1]);
      args[3] = gen_lowpart (HImode, operands[1]);
      output_asm_insn("mov  %2, %0", args);
      output_asm_insn("mov  %3, %1", args);
    }
    return("");
  }
  [(set_attr "length" "4,8,8,12,8")])


;;-------------------------------------------------------------------
;; Type Conversions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Zero Extend
;; If op1 is not a register, we need to mov the value to op0 first.  As a
;; result, R and Q constraints are different length to r.
;; Can't make this a split or expand as can't emit a mov from a QI to a HI
;;-------------------------------------

(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
        (zero_extend:HI (match_operand:QI 1 "general_operand" "0,R,Q")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("zero_extendqihi2", operands, 2);

    if (which_alternative > 0)
    {
      output_asm_insn ("movb %1, %0", operands);
    }

    return ("srl  %0, 8");
  }
  [(set_attr "length" "2,4,6")])


;;-------------------------------------
; TODO Could do a gen_lowpart into op0 to prevent the tmp
(define_expand "zero_extendqisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "")
        (zero_extend:SI (match_operand:QI 1 "general_operand" "")))]
  ""
  {
    tms9900_debug_operands ("zero_extendqisi2", operands, 2);
    rtx tmp = gen_reg_rtx (HImode);
    emit_insn (gen_zero_extendqihi2 (tmp, operands[1]));
    emit_insn (gen_zero_extendhisi2 (operands[0], tmp));
    DONE;
  })

;; TODO change to expand
(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
        (zero_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
  ""
  {
    tms9900_debug_operands ("zero_extendhisi2", operands, 2);
    rtx args[3];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    args[2] = operands[1];

    output_asm_insn("mov  %2, %1", args);
    output_asm_insn("clr  %0", args);
    return("");
  }
  [(set_attr "length" "4,8")])


;;-------------------------------------------------------------------
;; Sign Extend
;;-------------------------------------------------------------------

(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
        (sign_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("extendqihi2", operands, 2);
    if (which_alternative > 0)
    {
      output_asm_insn ("movb %1, %0", operands);
    }
    output_asm_insn("sra  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2,4,6")])
                         

(define_expand "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "")
        (sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  {
    tms9900_debug_operands ("extendqisi2", operands, 2);
    rtx tmp = gen_reg_rtx (HImode);
    emit_insn (gen_extendqihi2 (tmp, operands[1]));
    emit_insn (gen_extendhisi2 (operands[0], tmp));
    DONE;
  }
)

;;-------------------------------------
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
        (sign_extend:SI (match_operand:HI 1 "general_operand" "g,g")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("extendhisi2", operands, 2);
    rtx args[3];
    rtx offset[1];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    args[2] = operands[1];

    if(which_alternative == 1)
      offset[0] = GEN_INT(6);
    else
      offset[0] = GEN_INT(4);

    output_asm_insn("mov  %2, %1", args);
    /* sign extend.  If highpart is negative, seto, else clr.  This is slightly
     * cheaper (either 20 or 30 cycles) than doing sra 16 (44 cycles) */
    /* TODO zero extend is  more likely - reverse order */
    output_asm_insn("seto %0", args);
    output_asm_insn("jlt  $+%0", offset);
    output_asm_insn("clr  %0", args);
    return("");
  }
  [(set_attr "length" "8,12")])

;;-------------------------------------------------------------------
;; Truncate
;
;  swpb will suffice for non-strict in place truncation.  There is no strict variant of
;  truncate so I am assuming we don't care about unused bits.  SWPB doesn't
;  affect reg:CC.
;;-------------------------------------

(define_insn "trunchiqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q")
        (truncate:QI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("trunchiqi2", operands, 2);
    return ("swpb  %0");
  }
  [(set_attr "length" "2,4")])

;  This has to remain an insn. Tried an expand, but it is already a target of
;  another expand, so the modes were wrong
;
;  Now causing unrecog insn - try add reload_completed

(define_insn "truncsihi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
        (truncate:HI (match_operand:SI 1 "nonimmediate_operand" "rR>,Q,rR>,Q")))
   (clobber (reg:CC CC_REGNUM))]
  "reload_completed"
  {
    tms9900_debug_operands ("truncsihi2", operands, 2);
    // rtx args[2];
    // args[0] = gen_highpart (HImode, operands[1]);
    // args[0] = operands[0];
    operands[1] = gen_lowpart (HImode, operands[1]);

    return "mov  %1, %0";
    // printf ("modes=%s,%s\n",
    //     GET_MODE_NAME(GET_MODE(args[0])),
    //     GET_MODE_NAME(GET_MODE(args[1])));
    // emit_move_insn (args[0], args[1]);
    // return("");
    // DONE;
  }
  [(set_attr "length" "2,4,4,6")])

;; Change to insn.  exand causing problems with modes.  In place only as swpb
;; used
(define_insn "truncsiqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q")
        (truncate:QI (match_operand:SI 1 "nonimmediate_operand" "0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("truncsiqi2", operands, 2);
    operands[1] = gen_lowpart (HImode, operands[1]);
    output_asm_insn ("mov  %1, %0", operands);
    output_asm_insn ("swpb %0", operands);
    return "";
  }
)

;;-------------------------------------------------------------------
;;  Branch Instructions
;;-------------------------------------------------------------------

;;  This comment from visium .... which has similar instructions like mov that
;; clobber CC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Conditional branch instructions
;;
;; Note - we do not specify the two instructions necessary to perform
;; a compare-and-branch in the cbranch<mode>4 pattern because that would
;; allow the comparison to be moved away from the jump before the reload
;; pass has completed.  That would be problematical because reload can
;; generate instructions in between which would clobber the CC register.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;   [(const_int 0)]
; {
;   rtx flags = gen_rtx_REG (CCmode, CC_REGNUM);
; 
;   rtx x = gen_rtx_COMPARE (CCmode, operands[1], operands[2]);
;   x = gen_rtx_SET (flags, x);
;   emit_insn (x);
; 
;   x = gen_rtx_fmt_ee (code, VOIDmode, flags, const0_rtx);
;   x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, gen_rtx_LABEL_REF (Pmode, operands[3]),
;                             pc_rtx);
;   x = gen_rtx_SET (pc_rtx, x);
;   emit_jump_insn (x);
;   DONE;
; }


;; This from pdp11... implies similar, but much simpler md code....

;; These control RTL generation for conditional jump insns
;; and match them for register allocation.
;; Post reload these get expanded into insns that actually
;; manipulate the condition code registers.  We can't do that before
;; because instructions generated by reload clobber condition codes (new
;; CC design, type #2).

(define_expand "cbranch<mode>4"
  [(set (pc)
        (if_then_else (match_operator 0 "ordered_comparison_operator"
                       [(match_operand:QHint 1 "register_operand")
                        (match_operand:QHint 2 "register_operand")])
                      (label_ref (match_operand 3 "" ""))
                      (pc)))]
  ""
  "")

; still asserting in final.c:2783
; what's different?  ?? fixed by ?? on 26-dec

; This is the split at reload time.  Only emits the insn at reload complete
; using the # so emits a compare followed by a ifthenelse 

; Don't see why it has to be only registers?
;                       [(match_operand:QHint 1 "register_operand" "g")
;                        (match_operand:QHint 2 "register_operand" "g")])

; why does the if_then_else use the same operator on CC?  Shouldn't it just be
; zero?

(define_insn_and_split "*cbranch<mode>4_insn"
  [(set (pc)
        (if_then_else (match_operator 0 "ordered_comparison_operator"
                       [(match_operand:QHint 1 "nonimmediate_operand" "")
                        (match_operand:QHint 2 "general_operand" "")])
                      (label_ref (match_operand 3 "" ""))
                      (pc)))]
  ""
  "#"
  "reload_completed"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 1) (match_dup 2)))
   (set (pc)
        (if_then_else (match_op_dup 0
                      [(reg:CC CC_REGNUM) (const_int 0)])
                      (label_ref (match_dup 3))
                      (pc)))]
  "")

; this actually emits the code for the jump
(define_insn "*tms9900_cond_branch"
  [(set (pc)
        (if_then_else (match_operator 0 "ordered_comparison_operator"
                       [(reg:CC CC_REGNUM) (const_int 0)])
                      (label_ref (match_operand 1 "" ""))
                      (pc)))]
  "reload_completed"
  {
    tms9900_debug_operands ("cond_branch", operands, 2);
    return output_jump (operands, 0, get_attr_length (insn));
  }
  [(set (attr "length") (if_then_else (ior (lt (minus (match_dup 1)
                                                      (pc))
                                               (const_int MIN_BRANCH))
                                           (gt (minus (match_dup 1)
                                                      (pc))
                                               (const_int MAX_BRANCH)))
                                      (const_int 8)
                                      (const_int 4)))])

;;-------------------------------------------------------------------
;;  Jump Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Unconditional jump to label
;; TODO len was 14,12 even though there is no compare.  Is this why the
;; optimiser was loading labels into regs before branch?
(define_insn "jump"
  [(set (pc)
        (label_ref (match_operand 0 "" "")))]
  ""
  {
    if (get_attr_length (insn) == 4)
      return "b    @%l0 ; uncond-long";
    return "jmp  %l0 ; uncond-short";
  }

  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
                                                      (pc))
                                               (const_int MIN_BRANCH))
                                           (ge (minus (match_dup 0)
                                                      (pc))
                                               (const_int MAX_BRANCH)))
                                      (const_int 4)
                                      (const_int 2)))])



;;-------------------------------------------------------------------
;; Unconditional jump using pointer
(define_insn "indirect_jump"
  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "R,Q"))]
  ""
  "b    %0 ; indir"
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Unconditional jump using jump table
(define_insn "tablejump"
  [(clobber (match_scratch:HI 2 "=r,r"))
   (set (pc) (match_operand:HI 0 "nonimmediate_operand" "rR,Q"))
   (use (label_ref (match_operand 1 "" "")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    output_asm_insn("mov  %0, %2", operands);
    output_asm_insn("b    *%2 ; table",    operands);
    return(""); 
  }
  [(set_attr "length" "4,6")])



;;-------------------------------------------------------------------
;;  Bit Shift Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Arithmetic shift left
;;
; To shift by a value in a register, that value must be in r0.  We could try and
; teach gcc how to move registers between classes, but its just easier if we use
; r0 as a private clobber and do it ourselves.  If the result of the mov is
; zero, then we do nothing, since shifting by zero on tms9900 would actually shift
; by 16 which is not what is expected.  If the shift count is non zero but the
; lower 4 bits are zero, then we will shift by 16 but the request was to shift by
; at least 16 anyway so the result is the very same.

;; NOTE : On the TMS9900 a shift count of 0 is interpreted as
;; shift by 16, so test for 0 and jump over the shift if true.  Do the same in
;; all other shift by register insns as well.

;; If we are asked to shift by a constant 0 then we assert as the
;; compiler is being stupid.

;; Removed the assert, the compiler actually is that
;; stupid when expanding 32-bit shifts.  Make it an alternative with 0 length that does nothing

;;-------------------------------------------------------------------
(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
        (ashift:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
                   (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashlhi3", operands, 3);
    if (which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sla  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("sla  %0, %2", operands);
    }

    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])

;;-------------------------------------
;  Byte shift left differs in that we must ensure the lower byte is zeros

(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r,r,r")
        (ashift:QI (match_operand:QI 1 "register_operand" "0,0,0,0")
                   (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashlqi3", operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+8",       operands);  /* If shift count is zero, do nothing */
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, 0",     operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, %2",    operands);
    }

    return(""); 
  }
  [(set_attr "length" "10,12,0,6")])

;;-------------------------------------------------------------------
;; Arithmetic shift right

; Same for byte or word.

;;-------------------------------------

(define_insn "ashr<mode>3"
  [(set (match_operand:QHint 0 "register_operand" "=r,r,r,r")
        (ashiftrt:QHint (match_operand:QHint 1 "register_operand" "0,0,0,0")
                        (match_operand:HI 2 "nonmemory_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashr<mode>3", operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sra  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("sra  %0, %2", operands);
    }

    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])

;; Logical shift right
(define_insn "lshr<mode>3"
  [(set (match_operand:QHint 0 "register_operand" "=r,r,r,r")
        (lshiftrt:QHint (match_operand:QHint 1 "register_operand" "0,0,0,0")
                        (match_operand:HI 2 "nonmemory_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashr<mode>3", operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("srl  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("srl  %0, %2", operands);
    }

    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


;;-------------------------------------------------------------------
;; Rotate 


;;-------------------------------------
(define_expand "rotlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("rotlhi3", operands, 3);
      output_asm_insn("mov  %2, r0",  operands);
    if (GET_CODE (operands[2]) == CONST_INT)
      operands[2] = GEN_INT ((16 - INTVAL (operands[2])) % 16);
    else
      {
        rtx reg = gen_reg_rtx (HImode);
        emit_insn (gen_subhi3 (reg, GEN_INT (16), operands[2]));
        operands[2] = reg;
      }
  })


;;-------------------------------------
(define_insn "rotrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  "@
  src  %0, 0
  src  %0, %2" 
 [(set_attr "length" "2,2")])



;;-------------------------------------------------------------------
;;  Bitwise Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; And

; TODO gcc doesn't see that this insn does an implicit compare to zero
; use r0 isntead  [(clobber (match_scratch:HI 3                            "=r,  r,  r,  r,r, r,r, r"))
;;-------------------------------------
(define_insn "andhi3<cc_cc>"
  [(set (match_operand:HI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r, r,R>,Q")
        (and:HI (match_operand:HI 1 "nonimmediate_operand" "0,   0,  0,  0,0, 0,0, 0")
                (match_operand:HI 2 "general_operand"      "rR>, Q,  rR>,Q,OM,i,i, i")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("andhi3", operands, 3);
    tms9900_inline_debug ("; andhi3 alt=%d\n", which_alternative);

    /* TODO There is a case where the combiner fails to generate properly byte
     * aligned inputs to andhi3 due to using a subreg when it couldn't find a
     * match for zero extending a byte in a memory location.  My initial fix for
     * this was to write a variant of andhi3 that accepts subregs and do a byte
     * swap.  This did fix the andhi3 optimiser bug but what about the general
     * case?  Surely there is an easier way than to duplicate every insn and add
     * subreg and non subreg cases?  Its unclear why gcc even promotes byte ops
     * to int16 for binary and but not for binary or.  I added memory
     * constraints to the extend and trunc insns but this didn't help find a
     * match.  So rather than writing a duplicate of every HI insn that can
     * accept a subreg, I'm checking the offset of operands[1] below.  If non
     * zero this indicates a subreg and we emit a byte swap.  This may not be
     * the only place this is needed but andhi3 is the only known sighting of
     * this issue so far.
     */

    // If op[1] has an offset of -1 then it came from a paradoxical subreg and
    // the combiner has eliminated an extend insn and the byte is in the wrong
    // place.  Emit a swpb to fix it

    // TODO should refer to op[0] as op[1] has constraint '0' ?

    if (REG_ATTRS(operands[1]))
      printf("; off=%d\n", (int) REG_ATTRS(operands[1])->offset == -1);
    else
      printf ("; op1 no attrs\n");

    if (REG_ATTRS(operands[1]) && REG_ATTRS(operands[1])->offset.to_constant() == 1)
       output_asm_insn("swpb %0", operands);

    int val = INTVAL(operands[2]) & 0xFFFF;
    if(which_alternative == 4)
    {
      if(val == 0)
      {
        /* Result will be zero */
        output_asm_insn("clr  %0", operands);
      }
      else if(val == 0xFFFF)
      {
        /* No operation required */
        return("");
      }
    }
    else if(which_alternative == 5)
    {
      /* AND const value and register */
      output_asm_insn("andi %0, %2 ; HI", operands);
    }
    else if(which_alternative >= 6)
    {
      /* AND const value and memory */
      operands[2] = GEN_INT(~val);
      output_asm_insn("li   r0, %2", operands);
      output_asm_insn("szc  r0, %0", operands);
    }
    else
    {
      /* AND against non-const value by moving to r0 */
      output_asm_insn("mov  %2, r0", operands);
      output_asm_insn("inv  r0",     operands);
      output_asm_insn("szc  r0, %0", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,8,10,2,4,6,8")])


(define_insn "*andnothi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
        (and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0")
                (not:HI (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "szc  %2, %0"
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
        (and:HI (not:HI (match_operand:HI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:HI 2 "nonimmediate_operand" "0,0,0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "szc  %1, %0"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------
;  [(clobber (match_scratch:QI 3                            "=r,  r,  r,  r,r, r,r, r"))
(define_insn "andqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand"         "=rR>,Q,  rR>,Q,r, r,R>,Q")
        (and:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0, 0,0, 0")
                (match_operand:QI 2 "general_operand"      "rR>, rR>,Q,  Q,OM,i,i, i")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("andqi3", operands, 3);
    tms9900_inline_debug ("; andqi3 alt=%d\n", which_alternative);

    // If op[1] has an offset of 1 then (creating?) a paradoxical subreg and
    // the combiner has eliminated an (trunc?) insn and the byte is in the wrong
    // place.  Emit a swpb to fix it

    if (REG_ATTRS(operands[1]))
      printf("; off=%d\n", (int) REG_ATTRS(operands[1])->offset == 1);
    else
      printf ("; op1 no attrs\n");

    if (REG_ATTRS(operands[1]) && REG_ATTRS(operands[1])->offset.to_constant() == 1)
       output_asm_insn("swpb %0", operands);

    int val = (INTVAL(operands[2]) << 8) & 0xFF00;
    if (which_alternative == 4)
    {
      if(val == 0)
        output_asm_insn("clr %0", operands);
      else if(val == 0xff00)
        return("");
    }
    else if(which_alternative == 5)
    {
      /* AND const value and register */
      operands[2] = GEN_INT(val);
      output_asm_insn("andi %0, %2 ; QI", operands);
    }
    else if(which_alternative >= 6)
    {
      /* AND const value and memory */
      operands[2] = GEN_INT(~val);
      output_asm_insn("li   r0, %2", operands);
      output_asm_insn("szcb r0, %0", operands);
    }
    else
    {
      /* AND against non-const value */
      output_asm_insn("movb %2, r0", operands);
      output_asm_insn("inv  r0", operands);
      output_asm_insn("szcb r0, %0", operands);
    }
    return("");
  }
  [(set_attr "length" "6,8,8,10,2,4,6,8")])

(define_insn "*andnotqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
        (and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
                (not:QI (match_operand:QI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "szcb %2, %0"
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
        (and:QI (not:QI (match_operand:QI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:QI 2 "nonimmediate_operand" "0,0,0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "szcb %1, %0"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------------------------------------
;; Or


;;-------------------------------------
(define_insn "iorhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,r")
        (ior:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0,0,0,0,0")
                (match_operand:HI 2 "general_operand" "rR>,Q,rR>,Q,M,i")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("iorhi3", operands, 3);
    if (GET_CODE (operands[2]) == CONST_INT)
      {
        int val = INTVAL(operands[2]) & 0xFFFF;
        if(val == 0xFFFF)
          return "seto %0";
        else if(val == 0)
          return "";
        else
          return "ori  %0, %2";
      }
    return "soc  %2, %0";
  }
  [(set_attr "length" "2,4,4,6,4,2")])


;;-------------------------------------
(define_insn "iorqi3"
   [(set (match_operand:QI 0 "nonimmediate_operand"        "=rR>,Q,  rR>,Q,r")
        (ior:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0")
                (match_operand:QI 2 "general_operand"       "rR>,rR>,Q,  Q,i")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("iorqi3", operands, 3);
    if (which_alternative < 4)
      output_asm_insn("socb %2, %0", operands);
    else
    {
      int val = (INTVAL(operands[2]) << 8) & 0xFF00;
      tms9900_inline_debug ("; iorqi3 val=%X\n", val);
      rtx args[2];
      args[0] = operands[0];
      args[1] = GEN_INT(val);
      /* AND const value and register */
      if(val == 0)
        return("");
      else if(val == 0xff00)
        output_asm_insn("seto %0", args);
      else
        output_asm_insn("ori  %0, %1", args);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Xor


;;-------------------------------------
(define_insn "xorhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (xor:HI (match_operand:HI 1 "register_operand" "%0,0")
                (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("xorhi3", operands, 3);
    return "xor  %2, %0";
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; This works for regs only as xor is 16-bit only and should not be used on
;; memory locations as it will affect the neighbouring byte
(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
        (xor:QI (match_operand:QI 1 "register_operand" "%0")
                (match_operand:QI 2 "nonimmediate_operand" "r")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("xorqi3", operands, 3);
    return "xor  %2, %0";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Not
;;-------------------------------------
(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (not:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("one_cmplhi2", operands, 3);
    return "inv  %0";
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; This works for regs only as inv is 16-bit only and should not be used on
;; memory locations as it will affect the neighbouring byte
(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=r")
        (not:QI (match_operand:QI 1 "nonimmediate_operand" "0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("one_cmplqi2", operands, 3);
    return "inv  %0";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Arithmetic Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Add
;;-------------------------------------

(define_insn "addhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,r,rR>,Q")
        (plus:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0,0,0,0")
                 (match_operand:HI 2 "general_operand" "rR>LMNO,rR>LNMO,i,Q,Q")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("addhi3", operands, 3);
    switch(GET_CODE(operands[2]))
    {
      case CONST_INT:
      {
        if (INTVAL(operands[2]) == 1)
          return("inc  %0");
        else if (INTVAL(operands[2]) == -1)
          return("dec  %0");
        else if (INTVAL(operands[2]) == 2)
          return("inct %0");
        else if (INTVAL(operands[2]) == -2)
          return("dect %0");
        else
          return("ai   %0, %2");
      }

      case MEM:
      case REG:
        return ("a    %2, %0");

      default:
          return("ai   %0, %2");
    }
  }
  [(set_attr "length" "2,4,4,4,6")])


;;-------------------------------------
(define_insn "addqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r")
        (plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0,0,0")
                 (match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q,i")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("addqi3", operands, 3);
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      operands[2] = GEN_INT(INTVAL(operands[2]) * 256);
      return("ai   %0, %2");
    }
  return("ab   %2, %0");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Subtract


;;-------------------------------------

;;-------------------------------------
(define_insn "subhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
        (minus:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
                  (match_operand:HI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("subhi3", operands, 3);
    if(which_alternative < 4)
    {
      output_asm_insn("s    %2, %0",operands);
    }
    else
    {
      output_asm_insn("s    %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------
(define_insn "*rsubihi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (minus:HI (match_operand:HI 1 "immediate_operand" "i")
                  (match_operand:HI 2 "register_operand" "0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    if (INTVAL(operands[1]) == -1)
      output_asm_insn("inc  %0",operands);
    else if (INTVAL(operands[1]) == 1)
      output_asm_insn("dec  %0",operands);
    else if (INTVAL(operands[1]) == -2)
      output_asm_insn("inct %0",operands);
    else if (INTVAL(operands[1]) == 2)
      output_asm_insn("dect %0",operands);
    else
    {
      operands[1] = GEN_INT(-INTVAL(operands[1]));
      output_asm_insn("ai   %0, %1",operands);
    }
    output_asm_insn("neg  %0",operands);
    return "";
  }
  [(set_attr "length" "6")])


;;-------------------------------------
;; MGB TODO why negate?
(define_insn "subqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
        (minus:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
                  (match_operand:QI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("subqi3", operands, 3);
    if(which_alternative < 4)
    {
      output_asm_insn("sb   %2, %0",operands);
    }
    else
    {
      output_asm_insn("sb   %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------------------------------------
;; Multiply
;;
;;-------------------------------------
; Expand for signed HI = QI x QI
; TODO check sign of highpart of HI
(define_expand "mulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=r")
        (mult:HI (match_operand:QI 1 "register_operand" "r")
                 (match_operand:QI 2 "register_operand" "rRQ>")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("mulqihi3", operands, 3);

    rtx result = gen_reg_rtx (SImode);
    rtx op1 = gen_reg_rtx (HImode);
    rtx op2 = gen_reg_rtx (HImode);
    emit_insn (gen_extendqihi2 (op1, operands[1]));
    emit_insn (gen_extendqihi2 (op2, operands[2]));
    emit_move_insn(gen_highpart (HImode, result), op1);
    emit_insn(gen_tms9900_mul(result, result, op2));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
  }
)

;;-------------------------------------
; Expand for unsigned HI = QI x QI
;
(define_expand "umulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=r")
        (mult:HI (match_operand:QI 1 "register_operand" "r")
                 (match_operand:QI 2 "register_operand" "rRQ>")))]
  ""
  {
    tms9900_debug_operands ("umulqihi3", operands, 3);

    rtx result = gen_reg_rtx (SImode);
    rtx op1 = gen_reg_rtx (HImode);
    rtx op2 = gen_reg_rtx (HImode);

    /* Extend expects both regs to be the same but passing two operands is legit
     * as it forces the compiler to copy them to one reg first */
    emit_insn (gen_zero_extendqihi2 (op1, operands[1]));
    emit_insn (gen_zero_extendqihi2 (op2, operands[2]));
    emit_move_insn(gen_highpart (HImode, result), op1);
    emit_insn(gen_tms9900_mul(result, result, op2));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
  }
)

;;-------------------------------------
; Expand for signed SI = HI x HI
;
(define_expand "mulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulqihi3", operands, 3);
    tms9900_inline_debug ("; mulhisi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_tms9900_mul(result, result, operands[2]));
    emit_move_insn (operands[0], result);
    DONE;
  }
)

;;-------------------------------------
; Expand for unsigned SI = HI x HI
;
(define_expand "umulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("umulhisi3", operands, 3);
    tms9900_inline_debug ("; umulhisi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_tms9900_mul(result, result, operands[2]));
    emit_move_insn (operands[0], result);
    DONE;
  }
)

;;-------------------------------------
; expand HI=HIxHI to native SI=SIxHI

(define_expand "mulhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (mult:HI (match_operand:HI 1 "register_operand" "+0,0")
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulhi3", operands, 3);
    tms9900_inline_debug ("; mulhi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_tms9900_mul(result, result, operands[2]));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
   }
)

;;-------------------------------------
; This is the native multiplication on the tms9900.  SI=HIxHI
;  Note it is expected that op1 == op0 so we specify that op1 is SI.
;  All other variants, QIxQI, etc, should expand to this insn.
;  Also, mpy is unsigned so signed variants need to expand differently.
;  Signed vs unsigned makes no difference if operands and results are the same
;  size but will yield wrong results if result is wider than operands.

(define_insn "tms9900_mul"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (mult:SI (match_operand:SI 1 "register_operand" "0,0")
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("tms9900_mul", operands, 3);
    return ("mpy  %2, %0");
  }
  [(set_attr "length" "2,4")])

;;-------------------------------------
;; byte mul can only work in registers as we need to expand to HI mode

(define_expand "udivmodqi4"
  [(parallel [
     (set (match_operand:QI 0 "register_operand" "=r")
          (div:QI (match_operand:QI 1 "register_operand" "0")
                  (match_operand:QI 2 "register_operand" "r")))
     (set (match_operand:QI 3 "register_operand" "=r")
          (mod:QI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodqi4", operands, 4);

    /* Move and extend QI dividend to SI */
    rtx dividend = gen_reg_rtx (SImode);
    rtx scratch = gen_reg_rtx (HImode);
    emit_insn(gen_zero_extendqihi2 (scratch, operands[1]));
    emit_insn(gen_zero_extendhisi2 (dividend, scratch));

    /* Extend the divisor */
    rtx divisor = gen_reg_rtx (HImode);
    emit_insn(gen_zero_extendqihi2 (divisor, operands[2]));

    /* Do the division */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));

    /* Convert and store quotient from HI to QI */
    rtx quotient = gen_reg_rtx (HImode);
    emit_move_insn (quotient, gen_highpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[0], quotient));

    /* Convert and store quotient from HI to QI */
    rtx remainder = gen_reg_rtx (HImode);
    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[3], remainder));
    DONE;
  })

(define_expand "udivmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "+0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "+rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodhi4", operands, 4);
    tms9900_inline_debug ("; udivmodhi4 alt=%d\n", which_alternative);
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_zero_extendhisi2 (dividend, tmp));
    emit_insn(gen_udivmodsihi3(dividend, dividend, operands[2]));
    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));
    DONE;
  })



;;-------------------------------------
;; Signed div/mod.  Native method is unsigned so record the sign of the result
;; by xor'ing operands together to examine highest bit.  Then take abs of operands.
;; Correct the sign of the quotient after the operation
(define_expand "divmodqi4"
  [(parallel [
     (set (match_operand:QI 0 "register_operand" "=r,r")
          (div:QI (match_operand:QI 1 "register_operand" "0,0")
                  (match_operand:QI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:QI 3 "register_operand" "=r,r")
          (mod:QI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("divmodqi4", operands, 4);
    tms9900_inline_debug ("; divmodqi4 alt=%d\n", which_alternative);

    /* Find quotient sign */
    rtx sign = gen_reg_rtx (HImode); // sign of quotient
    emit_insn(gen_extendqihi2 (operands[1], sign));
    // emit_move_insn(sign, operands[1]);
    emit_insn(gen_extendqihi2 (operands[2], operands[2]));
    emit_insn(gen_xorhi3(sign, sign, operands[2]));

    /* Use temp for operand2 and get abs value */
    rtx divisor = gen_reg_rtx (HImode);
    emit_move_insn(divisor, operands[2]);
    emit_insn(gen_abshi2(divisor, divisor));

    /* Use temp for operand1, get absolute value and extend to SI.  We don't
     * have abssi2 so do abs on a tmp before extend  */
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_abshi2(tmp, tmp));
    emit_insn(gen_extendhisi2 (dividend, tmp));

    /* Perform division and modulus */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));

    /* Convert and store quotient from HI to QI */
    rtx quotient = gen_reg_rtx (HImode);
    emit_move_insn (quotient, gen_highpart (HImode, dividend));

    /* Correct sign of quotient */
    emit_insn(gen_divfixuphi2(quotient, sign));

    /* Convert and store quotient from HI to QI */
    emit_insn(gen_trunchiqi2 (operands[0], quotient));

    /* Convert and store remainder from HI to QI */
    rtx remainder = gen_reg_rtx (HImode);
    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[3], remainder));

    DONE;
  }
)


(define_expand "divmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("divmodhi4", operands, 4);
    tms9900_inline_debug ("; divmodhi4 alt=%d\n", which_alternative);
    // rtx insn, div_equal, mod_equal, equal;

    /* Find quotient sign */
    rtx sign = gen_reg_rtx (HImode); // sign of quotient
    emit_move_insn(sign, operands[1]);
    emit_insn(gen_xorhi3(sign, sign, operands[2]));

    /* Use temp for operand2 and get abs value */
    rtx divisor = gen_reg_rtx (HImode);
    emit_move_insn(divisor, operands[2]);
    emit_insn(gen_abshi2(divisor, divisor));

    /* Use temp for operand1, get absolute value and extend to SI.  We don't
     * have abssi2 so do abs on a tmp before extend  */
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_abshi2(tmp, tmp));
    emit_insn(gen_extendhisi2 (dividend, tmp));

    /* Perform division and modulus */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));

    /* Correct sign of quotient */
    emit_insn(gen_divfixuphi2(operands[0], sign));

    DONE;
  }
)


;;-------------------------------------------------------------------
;; Divide and Modulus
;; native method HI = SI / HI , HI = SI % HI
;;-------------------------------------
(define_insn "udivmodsihi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (ior:SI
          (ashift:SI
            (zero_extend:SI
              (div:HI (match_operand:SI 1 "register_operand" "0,0")
                      (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
            (const_int 16))
          (zero_extend:SI 
            (mod:HI (match_dup 1)
                    (match_dup 2)))))]
  ""
  {
    tms9900_debug_operands ("udivmodsihi3", operands, 3);
    output_asm_insn ("div  %2, %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])



(define_insn "divfixuphi2"
  [(set (match_operand:HI 1 "register_operand" "=r")
        (not:HI (match_dup 1)))
   (set (match_operand:HI 0 "register_operand" "=r")
        (if_then_else:HI (lt:HI (match_dup 1) (const_int 0))
           (neg:HI (match_dup 0)) (match_dup 0)))]
  ""
  {
    tms9900_debug_operands ("divfixuphi2", operands, 2);
    output_asm_insn("inv  %1", operands);
    output_asm_insn("jlt  $+4", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])




;;-------------------------------------------------------------------
;; Absolute Value


;;-------------------------------------
(define_insn "abshi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (abs:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("abshi2", operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO not safe for byte operations, but limited to r onyl for now
;; TO do bytes would need to declare a scratch - maybe overkill
(define_insn "absqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
        (abs:QI (match_operand:QI 1 "register_operand" "0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("absqi2", operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Negate

;;-------------------------------------
(define_insn "neghi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (neg:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("neghi2", operands, 2);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO andi only reqiured for strict
(define_insn "negqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
        (neg:QI (match_operand:QI 1 "register_operand" "0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("negqi2", operands, 2);
    output_asm_insn("andi %0, 0xFF00", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Other Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; No-op
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])



;;-------------------------------------------------------------------
;; Arithmetic shift left (for QI mode)

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 2 "register_operand" "")
	(ashift:HI (match_dup 0)
                   (plus:HI (match_operand:HI 3 "const_int_operand" "")
                            (match_operand:HI 4 "const_int_operand" ""))))]
  ""
  [(set (match_dup 2)
        (match_dup 1))
   (set (match_dup 2)
        (ashift:QI (match_dup 2)
                   (match_dup 3)))]
  "")



;;-------------------------------------
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 3 "register_operand" "")
	(ashiftrt:HI (match_operand:HI 4 "register_operand" "")
		     (match_operand:HI 5 "shift_count_operand" "")))
   (set (match_operand:QI 6 "register_operand" "")
        (subreg:QI (match_operand:HI 7 "register_operand" "") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (ashiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  "")

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 3 "register_operand" "")
	(lshiftrt:HI (match_operand:HI 4 "register_operand" "")
		     (match_operand:HI 5 "shift_count_operand" "")))
   (set (match_operand:QI 6 "register_operand" "")
        (subreg:QI (match_operand:HI 7 "register_operand" "") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (lshiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  "")
      

;;-------------------------------------------------------------------
;;  Optimizations For Comparisons
;;-------------------------------------------------------------------

;;-------------------------------------------------------------------
;; Optimization for X == {-2,-1,1,2}

;; This peephole is setting CC to be a register which breaks in gcc13.  I'm not
;; sure what it is trying to do.  Maybe it should be set (compare (op0 ?  Comment
;; out for now

; (define_peephole2
;   [(set (reg:CC CC_REGNUM)
; 	(compare:CC (match_operand:HI 0 "register_operand" "")
; 		 (match_operand:HI 1 "immediate_operand" "")))
;    (set (pc) (if_then_else (eq (reg:CC CC_REGNUM) (const_int 0))
;                            (label_ref (match_operand 2 "" ""))
;                            (pc)))]
;   "peep2_reg_dead_p(2, operands[0])"
;   [(set (match_operand:HI 0 "register_operand" "")
; 	(plus:HI (match_dup 0) (neg:HI (match_dup 1))))
;    (set (reg:CC CC_REGNUM) (match_dup 0))
;    (set (pc) (if_then_else (eq (reg:CC CC_REGNUM) (const_int 0))
;                            (label_ref (match_dup 2))
;                            (pc)))]
;   )

;; gcc matches this insn with a op2 value of zero - weird.  Ok - just emit a mov then.

(define_insn "*sub_const_hi"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (plus:HI (match_operand:HI 1 "register_operand" "0,0")
                 (neg:HI (match_operand:HI 2 "immediate_operand" "LMNO, i"))))]
  ""
  {
    tms9900_debug_operands ("sub_const_hi", operands, 3);
    operands[2] = GEN_INT(-INTVAL(operands[2]));
    switch(INTVAL(operands[2]))
    {
      case  0: output_asm_insn("mov  %1, %0", operands); break;
      case -2: output_asm_insn("dect %0",     operands); break;
      case -1: output_asm_insn("dec  %0",     operands); break;
      case  1: output_asm_insn("inc  %0",     operands); break;
      case  2: output_asm_insn("inct %0",     operands); break;
      default: output_asm_insn("ai   %0, %2", operands); break;
    }
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Optimization for X != {-2,-1,1,2}
; (define_peephole2
;   [(set (reg:CC CC_REGNUM)
; 	(compare:CC (match_operand:HI 0 "register_operand" "")
; 		 (match_operand:HI 1 "immediate_operand" "")))
;    (set (pc) (if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
;                            (label_ref (match_operand 2 "" ""))
;                            (pc)))]
;   "peep2_reg_dead_p(2, operands[0])"
;   [(set (match_operand:HI 0 "register_operand" "")
; 	(plus:HI (match_dup 0) (neg:HI (match_dup 1))))
;    (set (reg:CC CC_REGNUM) (match_dup 0))
;    (set (pc) (if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
;                            (label_ref (match_dup 2))
;                            (pc)))]
;   )


;;-------------------------------------------------------------------
;;  Optimizations For Byte Compares
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (gtu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (gtu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )

;; TODO assume this can be deleted
(define_insn "*cmpqi_as_hi"
  [(set (reg:CC CC_REGNUM)
      (compare:CC (match_operand:QI 0 "register_operand" "r")
         (plus:HI (match_operand:HI 1 "const_int_operand" "i")
            (mult:HI (match_operand:HI 2 "const_int_operand" "i")
               (match_operand:HI 3 "const_int_operand" "i")))))]
  "INTVAL(operands[3]) == 256 && (INTVAL(operands[1]) == 0 || INTVAL(operands[1]) == 255)"
  {
    operands[1] = GEN_INT(INTVAL(operands[2]) * 256 + INTVAL(operands[1]));
    return("ci   %0, %1");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (ltu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ltu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (geu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (geu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (leu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (leu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (gt (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                  (const_int 256)))))
   (set (pc) (if_then_else (gt (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (lt (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (lt (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (ge (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ge (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (le (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (le (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;;  Optimizations For Bit Shift And Cast
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (ashiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "")))
   (set (match_operand:QI 2 "register_operand" "")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  )

(define_insn "*ashiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("sra  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X = (unsigned int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (lshiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "")))
   (set (match_operand:QI 2 "register_operand" "")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_insn "*lshiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("srl  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (ashift:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "")))
   (set (match_operand:QI 2 "register_operand" "")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashift:HI (match_dup 0)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_insn "*ashift_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashift:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    operands[1] = GEN_INT(8 + INTVAL (operands[1]));
    output_asm_insn("sla  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (char X) >> N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (ashiftrt:QI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "")))
   (set (match_operand:HI 2 "register_operand" "")
        (sign_extend:HI (match_dup 0)))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI (match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 2 "register_operand" "")
        (ashiftrt:HI (match_dup 2)
            (match_operand:HI 3 "const_int_operand" "")))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 3) 
                      (const_int 8))))]
  )


(define_insn "*ashiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("sra  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (unsigned char X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (lshiftrt:HI (match_operand:HI 1 "register_operand" "")
            (match_operand:HI 2 "const_int_operand" "")))
   (set (match_operand:HI 3 "register_operand" "")
        (and:HI (match_operand:HI 4 "const_int_operand" "")
                (match_operand:HI 5 "const_int_operand" "")))]
  "(REGNO(operands[0]) == REGNO(operands[3])) && (INTVAL(operands[5]) == (1<<(8-INTVAL(operands[2])))-1)"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_dup 2) 
                      (const_int 8))))]
  )


(define_insn "*lshiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("srl  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = ((int)(char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (sign_extend:HI (match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 3 "register_operand" "")
        (ashift:HI (match_operand:HI 4 "register_operand" "")
                   (match_operand:HI 5 "const_int_operand" "")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (ashiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  )

(define_insn "*qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL(operands[3]);
    if(shift == 0) {
      output_asm_insn("swpb %0", operands);
      }
    else if(shift >= 1 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("sra  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0x00FF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned int)X = ((unsigned int)(unsigned char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (zero_extend:HI (match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 3 "register_operand" "")
        (ashift:HI (match_operand:HI 4 "register_operand" "")
                   (match_operand:HI 5 "const_int_operand" "")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (lshiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  )


(define_insn "*unsigned_qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL(operands[3]);
    if(shift >= 0 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("srl  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0xFFFF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned long)X = (unsigned long Y) >> 16
;;   Original code:
;;     mov  r3, r6
;;     mov  r4, r7
;;     mov  r6, r7
;;     clr  r6
;;
;;   Optimized:
;;     mov r3, r7
;;     clr r6
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "register_operand" ""))
   (set (match_operand:HI 2 "register_operand" "")
        (match_operand:HI 3 "register_operand" ""))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" ""))
    (set (match_operand:SI 5 "register_operand" "")
         (lshiftrt:SI (match_operand:SI 6 "register_operand" "")
                      (match_operand:HI 7 "const_int_operand" "")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 2) (match_dup 1))
   (set (match_dup 0) (const_int 0))]
)


(define_insn "*set_consthi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "const_int_operand" "i"))]
  ""
  {
    if(INTVAL(operands[1]) == 0) {
      output_asm_insn("clr  %0", operands);
    } else if((INTVAL(operands[1]) & 0xFFFF) == 0xFFFF) {
      output_asm_insn("seto  %0", operands);
    } else {
      output_asm_insn("li   %0, %1", operands);
    }
    return("");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for X = Y << 16
;;   Original code:
;;     mov  r4, r6
;;     mov  r5, r7
;;     mov  r7, r6
;;     clr  r7
;;
;;   Optimized:
;;     mov r5, r6
;;     clr r7
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "register_operand" ""))
   (set (match_operand:HI 2 "register_operand" "")
        (match_operand:HI 3 "register_operand" ""))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" ""))
    (set (match_operand:SI 5 "register_operand" "")
         (ashift:SI (match_operand:SI 6 "register_operand" "")
                      (match_operand:HI 7 "const_int_operand" "")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 0) (match_dup 3))
   (set (match_dup 2) (const_int 0))]
)


;-------------------------------------------------------------------
;; Optimization for byte array initializations
; This handles sequences like:
;   li   r1, >1200
;   movb r1, *r2
;   li   r1, >3400
;   movb r1, @1(r2)
;
; and converts to:
;   li   r1, >1234
;   movb r1, *r2
;   swpb r1
;   movb r1, @1(r2)
;
; This saves two bytes and is slightly faster
(define_peephole2
  [(match_scratch:HI 6 "")
   (set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (match_operand:QI 2 "nonimmediate_operand" "")
        (match_dup 0))
   (set (match_operand:QI 3 "register_operand" "")
        (match_operand:QI 4 "const_int_operand" ""))
   (set (match_operand:QI 5 "nonimmediate_operand" "")
        (match_dup 3))]
  "peep2_reg_dead_p(4, operands[0]) && peep2_reg_dead_p(4, operands[3])"
  [(set (match_dup 6)
        (ior:HI (ashift:HI (match_dup 1) 
                     (const_int 8))
             (match_dup 4)))
   (set (match_dup 2)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 8)) 1))
   (set (match_dup 5)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 0)) 1))]
)


(define_insn "*movhi_combine_consts"
  [(set (match_operand:HI 0 "register_operand" "")
        (ior:HI (ashift:HI (match_operand:QI 1 "const_int_operand" "")
                           (match_operand:QI 2 "const_int_operand" ""))
                (match_operand:QI 3 "const_int_operand" "")))]
  ""
  {
    operands[1] = GEN_INT(((INTVAL(operands[1]) & 0xFF) << 8) |
                           (INTVAL(operands[3]) & 0xFF));
    return "li   %0, %1";
  }
  [(set_attr "length" "4")])


(define_insn "*movqi_for_initializer"
  [(set (match_operand:QI 0 "memory_operand" "=rR>,Q")
        (subreg:QI (ashiftrt:HI (match_operand:HI 1 "register_operand" "r,r")
                              (match_operand:HI 2 "const_int_operand" "i,i")) 1))]
  ""
  {
    if(INTVAL(operands[2]) == 8)
    {
      output_asm_insn("movb %1, %0", operands);
    }
    else if(INTVAL(operands[2]) == 0)
    {
      output_asm_insn("swpb %1", operands);
      output_asm_insn("movb %1, %0", operands);
    }
   return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Optimization for memory-to-memory copies
;; Combine a mem-reg-mem copy into a mem-mem copy
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "memory_operand" ""))
   (set (match_operand:HI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 2 "memory_operand" "")
        (match_operand:HI 1 "memory_operand" ""))]
)

   
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "memory_operand" ""))
   (set (match_operand:QI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:QI 2 "memory_operand" "")
        (match_operand:QI 1 "memory_operand" ""))]
)


;;-------------------------------------------------------------------
;; Optimization for (int)X = (unsigned char)((int)X)
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (subreg:QI (match_operand:HI 1 "register_operand") 1))
   (set (match_operand:HI 2 "register_operand" "")
        (zero_extend:HI (match_dup 0)))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (match_dup 1))
   (set (match_dup 2)
        (and:HI (match_dup 2) (const_int 255)))]
)

(define_insn "*andi_const"
  [(set (match_operand:HI 0 "register_operand" "")
        (and:HI (match_dup 0)
                (match_operand:HI 1 "const_int_operand" "")))]
  ""
  {
    int val = INTVAL(operands[1]) & 0xFFFF;
    if(val == 0)
      return "clr  %0";
    else if(val == 0xFFFF)
      return "";
    else
      return "andi %0, %1";
  }
  [(set_attr "length" "4")])

