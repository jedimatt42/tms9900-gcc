;;- Machine description for the tms9900 for GNU C compiler
;; Copyright (C) 2010-2023 Free Software Foundation, Inc.
;; Contributed by Eric Welser and Mark Burkley (mark@burkley.net)

;; Copyright 2009 Eric Welser (EMW)
;; Copyright 2023 Mark Burkley (MGB)

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; MGB NOTES
;;    - rtx notation is insn(dst,src) but tms asm notation is <op> src,dst so
;;      beware of operand ordering
;;    - all byte (QI) ops need to have expands to cater for the fact that in
;;      TMS9900 a 16-bit operation can't be done on a reg that contains an 8-bit value
;;      unless it has been shifted by 8
;;    - Many byte insns are restricted to registers only as TMS9900 doesn't have
;;      byte version of abs, neg, etc.
;;    - Insns like exend, trunc, abs, etc, are done in place but passed two
;;      distinct params.  This is ok, the compiler is forced to move src and dst to the
;;      same reg by the "0" constraint.
;;    - optimiser doesn't understand opcodes, just insns.  So keep insns as
;;      short as possible.  One opcode preferable, two max.  Any more, use an expand instead
;;    - 32-bit arith insns have been moved to C code.  Emitting lengthy opcode
;;      sequences shouldn't be part of a md file.

(include "constraints.md")
(include "defines.md")
(include "predicates.md")

;;-------------------------------------------------------------------
;;  Function Calls
;;-------------------------------------------------------------------

;;-------------------------------------------------------------------
;; Jump to a subroutine which returns a value
(define_insn "call"
  [(call (match_operand:HI 0 "general_operand" "rR,Q")
         (match_operand:HI 1 "general_operand"  "g,g"))
  ]
  ""
  {
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %0", operands);
    else
      output_asm_insn("bl   %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)


;-------------------------------------------------------------------
; Jump to a subroutine which returns a value
(define_insn "call_value"
  [(set (match_operand 0 "" "")
        (call (match_operand:HI 1 "general_operand" "rR,Q")
              (match_operand:HI 2 "general_operand" "g,g")))
  ]
  ""
  {
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %1", operands);
    else
      output_asm_insn("bl   %1", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)


;;-------------------------------------------------------------------
;; Define function prologue
(define_expand "prologue"
  [(const_int 0)]
  ""
{
  tms9900_expand_prologue();
  DONE;
})


;;-------------------------------------------------------------------
;; Define function epilogue
(define_expand "epilogue"
  [(return)]
  ""
{
  tms9900_expand_epilogue(false);
  DONE;
})

(define_expand "sibcall_epilogue"
  [(return)]
  ""
{
  tms9900_expand_epilogue(true);
  DONE;
})


;;-------------------------------------------------------------------
;; Define function return
(define_insn "*rt"
  [(unspec [(match_operand:HI 0 "general_operand" "")] UNSPEC_RETURN)]
  ""
  "b    *r11"
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Comparison Instructions
;;-------------------------------------------------------------------

;; TODO cc0 deprecated https://gcc.gnu.org/wiki/CC0Transition
;; find-and-replace cc0 with reg:CC ST_REGNUM for now

(define_insn "tst<mode>"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QHint 0 "nonimmediate_operand" "rR,Q")
                    (const_int 0)))]
  ""
  {
    tms9900_debug_operands ("tst<mode>", operands, 1);
    return("mov<QHint:isfx> %0, %0");
  }
  [(set_attr "length" "2,6")])

;;-------------------------------------

; TEST if the clobber that breaks the match - nope
; TEST if needs reload_compelted - nope
; TEST if operands must match split - nope
; TEST if expand and then insn works - yes!

(define_expand "cmp<mode>"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QHint 0 "nonimmediate_operand" "")
                    (match_operand:QHint 1 "general_operand"      "")))]
  ""
  {
    tms9900_debug_operands ("cmp<mode>", operands, 2);
    rtx comp = operands[1];

    if (GET_CODE (operands[1]) == CONST_INT)
    {
      if (INTVAL (operands[1]) == 0)
      {
        printf ("why didn't you call tstqi?\n");
        emit_move_insn (operands[1], operands[1]);
        DONE;
      }

      if (REG_P (operands[0]) && <QHint:mname>==HImode)
      {
        emit_insn (gen_tms9900_cmphi_immed (operands[0], operands[1]));
        DONE;
      }

      comp = gen_reg_rtx (<QHint:mname>);
      emit_insn (gen_tms9900_mov<QHint:hmode>_const (comp, operands[1]));
    }

    emit_insn (gen_tms9900_cmp<QHint:hmode> (operands[0], comp));
    DONE;
  })

;; HImode only!  QI compare must use LI, CB
(define_insn "tms9900_cmphi_immed"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:HI 0 "nonimmediate_operand" "r")
                    (match_operand:HI 1 "immediate_operand" "i")))]
  ""
  "ci   %0, %1"
  [(set_attr "length" "4")])

;; Native compare for no immediates. Emit C or CB
(define_insn "tms9900_cmp<mode>"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QHint 0 "nonimmediate_operand" "rR,rR,Q, Q")
                    (match_operand:QHint 1 "nonimmediate_operand" "rR,Q, rR,Q")))]
  ""
  "c<QHint:isfx>   %0, %1"
  [(set_attr "length" "2,4,4,6")])

;; All MOV instructions in tms9900 set condition flags by doing implicit
;; compare to zero.  TODO Do we need a CCNZmode?

;;-------------------------------------------------------------------
;;  Move Operations
;;-------------------------------------------------------------------

; Define an empty insn for movqi and movhi as these are mandatory.  The actual
; emit will come from a post reload insn that clobbers CC
; "length" is defined even though this pattern won't appear at
; assembly language output time.  But the length is used by
; tms9900_insn_cost, before the post-reload splitter adds the
; CC clobber to the insn.
(define_insn "mov<mode>"
  [(set (match_operand:QHint 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r, r")
        (match_operand:QHint 1 "general_operand"       "rR>,Q,  rR>,Q,OM,i"))]
  ""
  ""
  [(set_attr "length" "2,4,4,6,2,4")])

; What does this do?  Define all setters as clobberCC after reload??

;; This splits all the integer moves: DI and SI modes as well as
;; the simple machine operations.
(define_split
  [(set (match_operand:QHint 0 "nonimmediate_operand" "")
        (match_operand:QHint 1 "general_operand" ""))]
  "reload_completed"
  [(parallel [(set (match_dup 0) (match_dup 1))
              (clobber (reg:CC CC_REGNUM))])]
  "")

; TEST - if these are defined early on, then they will match before a more
; general const mov
(define_insn "*tms9900_mov<mode>_zero"
  [(set (match_operand:QHint 0 "nonimmediate_operand" "=rR>,Q")
        (const_int 0))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "clr  %0"
  [(set_attr "length" "2,4")])

(define_insn "*tms9900_mov<mode>_minus_one"
  [(set (match_operand:QHint 0 "nonimmediate_operand" "=rR>,Q")
        (const_int -1))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "seto %0"
  [(set_attr "length" "2,4")])

(define_insn "tms9900_movhi_const"
  [(set (match_operand:HI 0 "register_operand"  "=r")
        (match_operand:HI 1 "immediate_operand" "i"))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "li   %0, %1"
  [(set_attr "length" "4")])

(define_insn "tms9900_movqi_const"
  [(set (match_operand:QI 0 "register_operand"  "=r")
        (match_operand:QI 1 "immediate_operand" "i"))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    int val = INTVAL(operands[1]) << 8;
    operands[1] = GEN_INT(val);
    return "li   %0, %1";
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Move byte value


;  I don't really know what this does but I think it is needed since the actual
;  insns will all be movhi_cc, movhi_nocc, etc.

; (define_expand "mov<mode>"
;   [(set (match_operand:QHint 0 "nonimmediate_operand" "")
;         (match_operand:QHint 1 "general_operand"       ""))]
;   ""
;   "")

;;-------------------------------------------------------------------
;; Move one or two-byte value

(define_insn "mov<mode><cc_cc>"
  [(set (match_operand:QHint 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q")
        (match_operand:QHint 1 "general_operand"      "rR>, Q,  rR>,Q"))
   (clobber (reg:CC CC_REGNUM))]
  "reload_completed"
  {
    tms9900_debug_operands ("mov<mode>", operands, 2);
    tms9900_inline_debug ("; mov<mode> alt=%d\n", which_alternative);
    #if 0
    if (which_alternative >= 4)
    {
      int val = INTVAL(operands[1]);

      // TODO by emitting either a 2-byte or 4-byte opcode for the same
      // alternative we are breaking the length attribute at the end.  This
      // doesn't seem to matter.  Does this mean length is not even needed?

      // TODO adding constraints OM before i works to capture consts we can
      // reduce

      if (val == 0)
        return("clr  %0");
      else if (val == 0xffff)
        return("seto %0");
      else
        return("li   %0, %1");
    }
    else
    #endif
    {
      return("mov<QHint:isfx> %1, %0");
    }
  }
  [(set_attr "length" "2,4,4,6")])

;;-------------------------------------------------------------------
;; Move four-byte value as two 2-byte regs.  If immediate, emit two movhi insns
;; with high and low part of constants.  Constraints O and M are allowed so we
;; can issue seto or clr for -1 and 0 respectively
;;
;; Changed this from an expand back to an insn - it would be better as an expand
;; if that could be made to work
;;-------------------------------------------------------------------
(define_insn "movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r")
        (match_operand:SI 1 "general_operand" "rR>,Q,rR>,Q,i"))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("movsi", operands, 2);
    tms9900_inline_debug ("; movsi alt=%d\n", which_alternative);

    rtx args[4];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);

    if (which_alternative >= 4)
    {
      args[2] = gen_rtx_CONST_INT (HImode, ((UINTVAL(operands[1])&0xffff0000)>>16));
      args[3] = gen_rtx_CONST_INT (HImode, (UINTVAL(operands[1])&0xffff));
      tms9900_inline_debug ("; movsi op1=%08X hi=%04X lo=%04X\n",
                            INTVAL (operands[1]),
                            INTVAL (args[2]),
                            INTVAL (args[3]));

      if (INTVAL(args[2]) == 0xffff)
        output_asm_insn("seto %0", args);
      else if (INTVAL(args[2]) == 0)
        output_asm_insn("clr  %0", args);
      else
        output_asm_insn("li   %0, %2", args);

      if (INTVAL(args[3]) == 0xffff)
        output_asm_insn("seto %1", args);
      else if (INTVAL(args[3]) == 0)
        output_asm_insn("clr  %1", args);
      else
        output_asm_insn("li   %1, %3", args);
    }
    else
    {
      args[2] = gen_highpart (HImode, operands[1]);
      args[3] = gen_lowpart (HImode, operands[1]);
      output_asm_insn("mov  %2, %0", args);
      output_asm_insn("mov  %3, %1", args);
    }
    return("");
  }
  [(set_attr "length" "4,8,8,12,8")])


;;-------------------------------------------------------------------
;; Type Conversions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Zero Extend
;; If op1 is not a register, we need to mov the value to op0 first.  As a
;; result, R and Q constraints are different length to r.
;; Can't make this a split or expand as can't emit a mov from a QI to a HI
;;-------------------------------------

(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
        (zero_extend:HI (match_operand:QI 1 "general_operand" "0,R,Q")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("zero_extendqihi2", operands, 2);

    if (which_alternative > 0)
    {
      output_asm_insn ("movb %1, %0", operands);
    }

    return ("srl  %0, 8");
  }
  [(set_attr "length" "2,4,6")])


;;-------------------------------------
; TODO Could do a gen_lowpart into op0 to prevent the tmp
(define_expand "zero_extendqisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "")
        (zero_extend:SI (match_operand:QI 1 "general_operand" "")))]
  ""
  {
    tms9900_debug_operands ("zero_extendqisi2", operands, 2);
    rtx tmp = gen_reg_rtx (HImode);
    emit_insn (gen_zero_extendqihi2 (tmp, operands[1]));
    emit_insn (gen_zero_extendhisi2 (operands[0], tmp));
    DONE;
  })

;; TODO change to expand
(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
        (zero_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
  ""
  {
    tms9900_debug_operands ("zero_extendhisi2", operands, 2);
    rtx args[3];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    args[2] = operands[1];

    output_asm_insn("mov  %2, %1", args);
    output_asm_insn("clr  %0", args);
    return("");
  }
  [(set_attr "length" "4,8")])


;;-------------------------------------------------------------------
;; Sign Extend
;;-------------------------------------------------------------------

(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
        (sign_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("extendqihi2", operands, 2);
    if (which_alternative > 0)
    {
      output_asm_insn ("movb %1, %0", operands);
    }
    output_asm_insn("sra  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2,4,6")])
                         

(define_expand "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "")
        (sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  {
    tms9900_debug_operands ("extendqisi2", operands, 2);
    rtx tmp = gen_reg_rtx (HImode);
    emit_insn (gen_extendqihi2 (tmp, operands[1]));
    emit_insn (gen_extendhisi2 (operands[0], tmp));
    DONE;
  }
)

;;-------------------------------------
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
        (sign_extend:SI (match_operand:HI 1 "general_operand" "g,g")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("extendhisi2", operands, 2);
    rtx args[3];
    rtx offset[1];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    args[2] = operands[1];

    if(which_alternative == 1)
      offset[0] = GEN_INT(6);
    else
      offset[0] = GEN_INT(4);

    output_asm_insn("mov  %2, %1", args);
    /* sign extend.  If highpart is negative, seto, else clr.  This is slightly
     * cheaper (either 20 or 30 cycles) than doing sra 16 (44 cycles) */
    /* TODO zero extend is  more likely - reverse order */
    output_asm_insn("seto %0", args);
    output_asm_insn("jlt  $+%0", offset);
    output_asm_insn("clr  %0", args);
    return("");
  }
  [(set_attr "length" "8,12")])

;;-------------------------------------------------------------------
;; Truncate
;
;  swpb will suffice for non-strict in place truncation.  There is no strict variant of
;  truncate so I am assuming we don't care about unused bits.  SWPB doesn't
;  affect reg:CC.
;;-------------------------------------

(define_insn "trunchiqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q")
        (truncate:QI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("trunchiqi2", operands, 2);
    return ("swpb  %0");
  }
  [(set_attr "length" "2,4")])

;  This has to remain an insn. Tried an expand, but it is already a target of
;  another expand, so the modes were wrong
;
;  Now causing unrecog insn - try add reload_completed

(define_insn "truncsihi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
        (truncate:HI (match_operand:SI 1 "nonimmediate_operand" "rR>,Q,rR>,Q")))
   (clobber (reg:CC CC_REGNUM))]
  "reload_completed"
  {
    tms9900_debug_operands ("truncsihi2", operands, 2);
    // rtx args[2];
    // args[0] = gen_highpart (HImode, operands[1]);
    // args[0] = operands[0];
    operands[1] = gen_lowpart (HImode, operands[1]);

    return "mov  %1, %0";
    // printf ("modes=%s,%s\n",
    //     GET_MODE_NAME(GET_MODE(args[0])),
    //     GET_MODE_NAME(GET_MODE(args[1])));
    // emit_move_insn (args[0], args[1]);
    // return("");
    // DONE;
  }
  [(set_attr "length" "2,4,4,6")])

;; Change to insn.  exand causing problems with modes.  In place only as swpb
;; used
(define_insn "truncsiqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q")
        (truncate:QI (match_operand:SI 1 "nonimmediate_operand" "0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("truncsiqi2", operands, 2);
    operands[1] = gen_lowpart (HImode, operands[1]);
    output_asm_insn ("mov  %1, %0", operands);
    output_asm_insn ("swpb %0", operands);
    return "";
  }
)

;;-------------------------------------------------------------------
;;  Branch Instructions
;;-------------------------------------------------------------------

;;  This comment from visium .... which has similar instructions like mov that
;; clobber CC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Conditional branch instructions
;;
;; Note - we do not specify the two instructions necessary to perform
;; a compare-and-branch in the cbranch<mode>4 pattern because that would
;; allow the comparison to be moved away from the jump before the reload
;; pass has completed.  That would be problematical because reload can
;; generate instructions in between which would clobber the CC register.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;   [(const_int 0)]
; {
;   rtx flags = gen_rtx_REG (CCmode, CC_REGNUM);
; 
;   rtx x = gen_rtx_COMPARE (CCmode, operands[1], operands[2]);
;   x = gen_rtx_SET (flags, x);
;   emit_insn (x);
; 
;   x = gen_rtx_fmt_ee (code, VOIDmode, flags, const0_rtx);
;   x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, gen_rtx_LABEL_REF (Pmode, operands[3]),
; 			    pc_rtx);
;   x = gen_rtx_SET (pc_rtx, x);
;   emit_jump_insn (x);
;   DONE;
; }


;; This from pdp11... implies similar, but much simpler md code....

;; These control RTL generation for conditional jump insns
;; and match them for register allocation.
;; Post reload these get expanded into insns that actually
;; manipulate the condition code registers.  We can't do that before
;; because instructions generated by reload clobber condition codes (new
;; CC design, type #2).

(define_expand "cbranch<mode>4"
  [(set (pc)
        (if_then_else (match_operator 0 "ordered_comparison_operator"
                       [(match_operand:QHint 1 "register_operand")
                        (match_operand:QHint 2 "register_operand")])
                      (label_ref (match_operand 3 "" ""))
                      (pc)))]
  ""
  "")

; still asserting in final.c:2783
; what's different?  ?? fixed by ?? on 26-dec

; This is the split at reload time.  Only emits the insn at reload complete
; using the # so emits a compare followed by a ifthenelse 
(define_insn_and_split "*cbranch<mode>4_insn"
  [(set (pc)
        (if_then_else (match_operator 0 "ordered_comparison_operator"
                       [(match_operand:QHint 1 "register_operand" "g")
                        (match_operand:QHint 2 "register_operand" "g")])
                      (label_ref (match_operand 3 "" ""))
                      (pc)))]
  ""
  "#"
  "reload_completed"
  [(set (reg:CC CC_REGNUM)
	(compare:CC (match_dup 1) (match_dup 2)))
   (set (pc)
	(if_then_else (match_op_dup 0
                      [(reg:CC CC_REGNUM) (const_int 0)])
		      (label_ref (match_dup 3))
		      (pc)))]
  "")

; this actually emits the code for the jump
(define_insn "*tms9900_cond_branch"
  [(set (pc)
        (if_then_else (match_operator 0 "ordered_comparison_operator"
                       [(reg:CC CC_REGNUM) (const_int 0)])
                      (label_ref (match_operand 1 "" ""))
                      (pc)))]
  "reload_completed"
  {
    tms9900_debug_operands ("cond_branch", operands, 2);
    return output_jump (operands, 0, get_attr_length (insn));
  }
  [(set (attr "length") (if_then_else (ior (lt (minus (match_dup 1)
                                                      (pc))
                                               (const_int MIN_BRANCH))
                                           (gt (minus (match_dup 1)
                                                      (pc))
                                               (const_int MAX_BRANCH)))
                                      (const_int 8)
                                      (const_int 4)))])

;;-------------------------------------------------------------------
;;  Jump Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Unconditional jump to label
;; TODO len was 14,12 even though there is no compare.  Is this why the
;; optimiser was loading labels into regs before branch?
(define_insn "jump"
  [(set (pc)
        (label_ref (match_operand 0 "" "")))]
  ""
  {
    if (get_attr_length (insn) == 4)
      return "b    @%l0 ; uncond-long";
    return "jmp  %l0 ; uncond-short";
  }

  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
                                                      (pc))
                                               (const_int MIN_BRANCH))
                                           (ge (minus (match_dup 0)
                                                      (pc))
                                               (const_int MAX_BRANCH)))
                                      (const_int 4)
                                      (const_int 2)))])



;;-------------------------------------------------------------------
;; Unconditional jump using pointer
(define_insn "indirect_jump"
  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "R,Q"))]
  ""
  "b    %0 ; indir"
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Unconditional jump using jump table
(define_insn "tablejump"
  [(clobber (match_scratch:HI 2 "=r,r"))
   (set (pc) (match_operand:HI 0 "nonimmediate_operand" "rR,Q"))
   (use (label_ref (match_operand 1 "" "")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    output_asm_insn("mov  %0, %2", operands);
    output_asm_insn("b    *%2 ; table",    operands);
    return(""); 
  }
  [(set_attr "length" "4,6")])



;;-------------------------------------------------------------------
;;  Bit Shift Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Arithmetic shift left
;;
;; NOTE : On the TMS9900 a shift count of 0 is interpreted as
;; shift by 16, so test for 0 and jump over the shift if true.  Do the same in
;; all other shift by register insns as well.
;;-------------------------------------------------------------------
(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (ashift:HI (match_operand:HI 1 "register_operand" "0,0")
                   (match_operand:HI 2 "shift_count_operand" "r,i")))]
  ""
  {
    tms9900_debug_operands ("ashlhi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("andi r0, >f",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sla  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sla  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "8,2")])

;;-------------------------------------
(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
        (ashift:QI (match_operand:QI 1 "register_operand" "0,0")
                   (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("ashlqi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("andi r0, >f",  operands);
      output_asm_insn("jeq  $+8",       operands);  /* If shift count is zero, do nothing */
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "12,6")])




;;-------------------------------------------------------------------
;; Arithmetic shift right


; To shift by a value in a register, that value must be in R0.  We could try and
; teach gcc how to move registers between classes, but its just easier if we use
; r0 as a private clobber and do it ourselves.  If the result of the mov is
; zero, then we do nothing, since shifting by zero on tms9900 would actually shift
; by 16 which is not what is expected.  If the shift count is non zero but the
; lower 4 bits are zero, then we will shift by 16 but the request was to shift by
; at least 16 anyway so the result is there very same.
;;-------------------------------------
(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (ashiftrt:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "nonmemory_operand" "r,i")))]
  ""
  {
    tms9900_debug_operands ("ashrhi3", operands, 3);
    if(which_alternative == 0)
    {
      // output_asm_insn("andi r0, >f",  operands);
      // output_asm_insn("jeq  $+4",    operands);
      // output_asm_insn("sra  %0, 0",  operands);
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sra  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sra  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "8,2")])


;;-------------------------------------
(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
        (ashiftrt:QI (match_operand:QI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("ashrqi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("andi r0, >f",  operands);
      output_asm_insn("jeq  $+4",       operands);
      output_asm_insn("sra  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sra  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "8,2")])


;;-------------------------------------------------------------------
;; Logical shift right



;;-------------------------------------
(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (lshiftrt:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("lshrhi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("andi r0, >f",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("srl  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("srl  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "8,2")])


;;-------------------------------------
(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
        (lshiftrt:QI (match_operand:QI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("lshrqi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("andi r0, >f",  operands);
      output_asm_insn("jeq  $+4",       operands);
      output_asm_insn("srl  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("srl  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "8,2")])



;;-------------------------------------------------------------------
;; Rotate 


;;-------------------------------------
(define_expand "rotlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("rotlhi3", operands, 3);
    if (GET_CODE (operands[2]) == CONST_INT)
      operands[2] = GEN_INT ((16 - INTVAL (operands[2])) % 16);
    else
      {
        rtx reg = gen_reg_rtx (HImode);
        emit_insn (gen_subhi3 (reg, GEN_INT (16), operands[2]));
        operands[2] = reg;
      }
  })


;;-------------------------------------
(define_insn "rotrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  "@
  src  %0, 0
  src  %0, %2" 
 [(set_attr "length" "2,2")])



;;-------------------------------------------------------------------
;;  Bitwise Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; And


;;-------------------------------------
(define_insn "andhi3"
  [(clobber (match_scratch:HI 3                            "=r,  r,  r,  r,r, r,r, r"))
   (set (match_operand:HI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r, r,R>,Q")
        (and:HI (match_operand:HI 1 "nonimmediate_operand" "0,   0,  0,  0,0, 0,0, 0")
                (match_operand:HI 2 "general_operand"      "rR>, Q,  rR>,Q,OM,i,i, i")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("andhi3", operands, 3);
    tms9900_inline_debug ("; andhi3 alt=%d\n", which_alternative);

    /* TODO There is a case where the combiner fails to generate properly byte
     * aligned inputs to andhi3 due to using a subreg when it couldn't find a
     * match for zero extending a byte in a memory location.  My initial fix for
     * this was to write a variant of andhi3 that accepts subregs and do a byte
     * swap.  This did fix the andhi3 optimiser bug but what about the general
     * case?  Surely there is an easier way than to duplicate every insn and add
     * subreg and non subreg cases?  Its unclear why gcc even promotes byte ops
     * to int16 for binary and but not for binary or.  I added memory
     * constraints to the extend and trunc insns but this didn't help find a
     * match.  So rather than writing a duplicate of every HI insn that can
     * accept a subreg, I'm checking the offset of operands[1] below.  If non
     * zero this indicates a subreg and we emit a byte swap.  This may not be
     * the only place this is needed but andhi3 is the only known sighting of
     * this issue so far.
     */

    // If op[1] has an offset of -1 then it came from a paradoxical subreg and
    // the combiner has eliminated an extend insn and the byte is in the wrong
    // place.  Emit a swpb to fix it

    // TODO should refer to op[0] as op[1] has constraint '0' ?

    if (REG_ATTRS(operands[1]))
      printf("; off=%d\n", (int) REG_ATTRS(operands[1])->offset == -1);
    else
      printf ("; op1 no attrs\n");

    if (REG_ATTRS(operands[1]) && REG_ATTRS(operands[1])->offset.to_constant() == 1)
       output_asm_insn("swpb %0", operands);

    int val = INTVAL(operands[2]) & 0xFFFF;
    if(which_alternative == 4)
    {
      if(val == 0)
      {
        /* Result will be zero */
        output_asm_insn("clr  %0", operands);
      }
      else if(val == 0xFFFF)
      {
        /* No operation required */
        return("");
      }
    }
    else if(which_alternative == 5)
    {
      /* AND const value and register */
      output_asm_insn("andi %0, %2 ; HI", operands);
    }
    else if(which_alternative >= 6)
    {
      /* AND const value and memory */
      operands[2] = GEN_INT(~val);
      output_asm_insn("li   %3, %2", operands);
      output_asm_insn("szc  %3, %0", operands);
    }
    else
    {
      /* AND against non-const value */
      if(!rtx_equal_p(operands[2], operands[3]))
      {
        output_asm_insn("mov  %2, %3", operands);
      }
      output_asm_insn("inv  %3",     operands);
      output_asm_insn("szc  %3, %0", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,8,10,2,4,6,8")])


(define_insn "*andnothi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
        (and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0")
                (not:HI (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "szc  %2, %0"
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
        (and:HI (not:HI (match_operand:HI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:HI 2 "nonimmediate_operand" "0,0,0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "szc  %1, %0"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------
(define_insn "andqi3"
  [(clobber (match_scratch:QI 3                            "=r,  r,  r,  r,r, r,r, r"))
   (set (match_operand:QI 0 "nonimmediate_operand"         "=rR>,Q,  rR>,Q,r, r,R>,Q")
        (and:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0, 0,0, 0")
                (match_operand:QI 2 "general_operand"      "rR>, rR>,Q,  Q,OM,i,i, i")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("andqi3", operands, 3);
    tms9900_inline_debug ("; andqi3 alt=%d\n", which_alternative);

    // If op[1] has an offset of 1 then (creating?) a paradoxical subreg and
    // the combiner has eliminated an (trunc?) insn and the byte is in the wrong
    // place.  Emit a swpb to fix it

    if (REG_ATTRS(operands[1]))
      printf("; off=%d\n", (int) REG_ATTRS(operands[1])->offset == 1);
    else
      printf ("; op1 no attrs\n");

    if (REG_ATTRS(operands[1]) && REG_ATTRS(operands[1])->offset.to_constant() == 1)
       output_asm_insn("swpb %0", operands);

    int val = (INTVAL(operands[2]) << 8) & 0xFF00;
    if (which_alternative == 4)
    {
      if(val == 0)
        output_asm_insn("clr %0", operands);
      else if(val == 0xff00)
        return("");
    }
    else if(which_alternative == 5)
    {
      /* AND const value and register */
      operands[2] = GEN_INT(val);
      output_asm_insn("andi %0, %2 ; QI", operands);
    }
    else if(which_alternative >= 6)
    {
      /* AND const value and memory */
      operands[2] = GEN_INT(~val);
      output_asm_insn("li   %3, %2", operands);
      output_asm_insn("szcb %3, %0", operands);
    }
    else
    {
      /* AND against non-const value */
      output_asm_insn("movb %2, %3", operands);
      output_asm_insn("inv  %3", operands);
      output_asm_insn("szcb %3, %0", operands);
    }
    return("");
  }
  [(set_attr "length" "6,8,8,10,2,4,6,8")])

(define_insn "*andnotqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
        (and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
                (not:QI (match_operand:QI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "szcb %2, %0"
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
        (and:QI (not:QI (match_operand:QI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:QI 2 "nonimmediate_operand" "0,0,0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  "szcb %1, %0"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------------------------------------
;; Or


;;-------------------------------------
(define_insn "iorhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,r")
        (ior:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0,0,0,0,0")
                (match_operand:HI 2 "general_operand" "rR>,Q,rR>,Q,i,M")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("iorhi3", operands, 3);
    if (GET_CODE (operands[2]) == CONST_INT)
      {
        int val = INTVAL(operands[2]) & 0xFFFF;
        if(val == 0xFFFF)
          return "seto %0";
        else if(val == 0)
          return "";
        else
          return "ori  %0, %2";
      }
    return "soc  %2, %0";
  }
  [(set_attr "length" "2,4,4,6,4,2")])


;;-------------------------------------
(define_insn "iorqi3"
   [(set (match_operand:QI 0 "nonimmediate_operand"        "=rR>,Q,  rR>,Q,r")
        (ior:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0")
                (match_operand:QI 2 "general_operand"       "rR>,rR>,Q,  Q,i")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("iorqi3", operands, 3);
    if (which_alternative < 4)
      output_asm_insn("socb %2, %0", operands);
    else
    {
      int val = (INTVAL(operands[2]) << 8) & 0xFF00;
      tms9900_inline_debug ("; iorqi3 val=%X\n", val);
      rtx args[2];
      args[0] = operands[0];
      args[1] = GEN_INT(val);
      /* AND const value and register */
      if(val == 0)
        return("");
      else if(val == 0xff00)
        output_asm_insn("seto %0", args);
      else
        output_asm_insn("ori  %0, %1", args);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Xor


;;-------------------------------------
(define_insn "xorhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (xor:HI (match_operand:HI 1 "register_operand" "%0,0")
                (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("xorhi3", operands, 3);
    return "xor  %2, %0";
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; This works for regs only as xor is 16-bit only and should not be used on
;; memory locations as it will affect the neighbouring byte
(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
        (xor:QI (match_operand:QI 1 "register_operand" "%0")
                (match_operand:QI 2 "nonimmediate_operand" "r")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("xorqi3", operands, 3);
    return "xor  %2, %0";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Not
;;-------------------------------------
(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (not:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("one_cmplhi2", operands, 3);
    return "inv  %0";
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; This works for regs only as inv is 16-bit only and should not be used on
;; memory locations as it will affect the neighbouring byte
(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=r")
        (not:QI (match_operand:QI 1 "nonimmediate_operand" "0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("one_cmplqi2", operands, 3);
    return "inv  %0";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Arithmetic Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Add
;;-------------------------------------

(define_insn "addhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,r,rR>,Q")
        (plus:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0,0,0,0")
                 (match_operand:HI 2 "general_operand" "rR>LMNO,rR>LNMO,i,Q,Q")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("addhi3", operands, 3);
    switch(GET_CODE(operands[2]))
    {
      case CONST_INT:
      {
        if (INTVAL(operands[2]) == 1)
          return("inc  %0");
        else if (INTVAL(operands[2]) == -1)
          return("dec  %0");
        else if (INTVAL(operands[2]) == 2)
          return("inct %0");
        else if (INTVAL(operands[2]) == -2)
          return("dect %0");
        else
          return("ai   %0, %2");
      }

      case MEM:
      case REG:
        return ("a    %2, %0");

      default:
          return("ai   %0, %2");
    }
  }
  [(set_attr "length" "2,4,4,4,6")])


;;-------------------------------------
(define_insn "addqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r")
        (plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0,0,0")
                 (match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q,i")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("addqi3", operands, 3);
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      operands[2] = GEN_INT(INTVAL(operands[2]) * 256);
      return("ai   %0, %2");
    }
  return("ab   %2, %0");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Subtract


;;-------------------------------------

;;-------------------------------------
(define_insn "subhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
        (minus:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
                  (match_operand:HI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("subhi3", operands, 3);
    if(which_alternative < 4)
    {
      output_asm_insn("s    %2, %0",operands);
    }
    else
    {
      output_asm_insn("s    %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------
(define_insn "*rsubihi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (minus:HI (match_operand:HI 1 "immediate_operand" "i")
                  (match_operand:HI 2 "register_operand" "0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    if (INTVAL(operands[1]) == -1)
      output_asm_insn("inc  %0",operands);
    else if (INTVAL(operands[1]) == 1)
      output_asm_insn("dec  %0",operands);
    else if (INTVAL(operands[1]) == -2)
      output_asm_insn("inct %0",operands);
    else if (INTVAL(operands[1]) == 2)
      output_asm_insn("dect %0",operands);
    else
    {
      operands[1] = GEN_INT(-INTVAL(operands[1]));
      output_asm_insn("ai   %0, %1",operands);
    }
    output_asm_insn("neg  %0",operands);
    return "";
  }
  [(set_attr "length" "6")])


;;-------------------------------------
;; MGB TODO why negate?
(define_insn "subqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
        (minus:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
                  (match_operand:QI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("subqi3", operands, 3);
    if(which_alternative < 4)
    {
      output_asm_insn("sb   %2, %0",operands);
    }
    else
    {
      output_asm_insn("sb   %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------------------------------------
;; Multiply
;;
;;-------------------------------------
; Expand for signed HI = QI x QI
; TODO check sign of highpart of HI
(define_expand "mulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=r")
        (mult:HI (match_operand:QI 1 "register_operand" "r")
                 (match_operand:QI 2 "register_operand" "rRQ>")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("mulqihi3", operands, 3);

    rtx result = gen_reg_rtx (SImode);
    rtx op1 = gen_reg_rtx (HImode);
    rtx op2 = gen_reg_rtx (HImode);
    emit_insn (gen_extendqihi2 (op1, operands[1]));
    emit_insn (gen_extendqihi2 (op2, operands[2]));
    emit_move_insn(gen_highpart (HImode, result), op1);
    emit_insn(gen_tms9900_mul(result, result, op2));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
  }
)

;;-------------------------------------
; Expand for unsigned HI = QI x QI
;
(define_expand "umulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=r")
        (mult:HI (match_operand:QI 1 "register_operand" "r")
                 (match_operand:QI 2 "register_operand" "rRQ>")))]
  ""
  {
    tms9900_debug_operands ("umulqihi3", operands, 3);

    rtx result = gen_reg_rtx (SImode);
    rtx op1 = gen_reg_rtx (HImode);
    rtx op2 = gen_reg_rtx (HImode);

    /* Extend expects both regs to be the same but passing two operands is legit
     * as it forces the compiler to copy them to one reg first */
    emit_insn (gen_zero_extendqihi2 (op1, operands[1]));
    emit_insn (gen_zero_extendqihi2 (op2, operands[2]));
    emit_move_insn(gen_highpart (HImode, result), op1);
    emit_insn(gen_tms9900_mul(result, result, op2));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
  }
)

;;-------------------------------------
; Expand for signed SI = HI x HI
;
(define_expand "mulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulqihi3", operands, 3);
    tms9900_inline_debug ("; mulhisi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_tms9900_mul(result, result, operands[2]));
    emit_move_insn (operands[0], result);
    DONE;
  }
)

;;-------------------------------------
; Expand for unsigned SI = HI x HI
;
(define_expand "umulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("umulhisi3", operands, 3);
    tms9900_inline_debug ("; umulhisi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_tms9900_mul(result, result, operands[2]));
    emit_move_insn (operands[0], result);
    DONE;
  }
)

;;-------------------------------------
; expand HI=HIxHI to native SI=SIxHI

(define_expand "mulhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (mult:HI (match_operand:HI 1 "register_operand" "+0,0")
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulhi3", operands, 3);
    tms9900_inline_debug ("; mulhi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_tms9900_mul(result, result, operands[2]));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
   }
)

;;-------------------------------------
; This is the native multiplication on the tms9900.  SI=HIxHI
;  Note it is expected that op1 == op0 so we specify that op1 is SI.
;  All other variants, QIxQI, etc, should expand to this insn.
;  Also, mpy is unsigned so signed variants need to expand differently.
;  Signed vs unsigned makes no difference if operands and results are the same
;  size but will yield wrong results if result is wider than operands.

(define_insn "tms9900_mul"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (mult:SI (match_operand:SI 1 "register_operand" "0,0")
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("tms9900_mul", operands, 3);
    return ("mpy  %2, %0");
  }
  [(set_attr "length" "2,4")])

;;-------------------------------------
;; byte mul can only work in registers as we need to expand to HI mode

(define_expand "udivmodqi4"
  [(parallel [
     (set (match_operand:QI 0 "register_operand" "=r")
          (div:QI (match_operand:QI 1 "register_operand" "0")
                  (match_operand:QI 2 "register_operand" "r")))
     (set (match_operand:QI 3 "register_operand" "=r")
          (mod:QI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodqi4", operands, 4);

    /* Move and extend QI dividend to SI */
    rtx dividend = gen_reg_rtx (SImode);
    rtx scratch = gen_reg_rtx (HImode);
    emit_insn(gen_zero_extendqihi2 (scratch, operands[1]));
    emit_insn(gen_zero_extendhisi2 (dividend, scratch));

    /* Extend the divisor */
    rtx divisor = gen_reg_rtx (HImode);
    emit_insn(gen_zero_extendqihi2 (divisor, operands[2]));

    /* Do the division */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));

    /* Convert and store quotient from HI to QI */
    rtx quotient = gen_reg_rtx (HImode);
    emit_move_insn (quotient, gen_highpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[0], quotient));

    /* Convert and store quotient from HI to QI */
    rtx remainder = gen_reg_rtx (HImode);
    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[3], remainder));
    DONE;
  })

(define_expand "udivmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "+0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "+rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodhi4", operands, 4);
    tms9900_inline_debug ("; udivmodhi4 alt=%d\n", which_alternative);
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_zero_extendhisi2 (dividend, tmp));
    emit_insn(gen_udivmodsihi3(dividend, dividend, operands[2]));
    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));
    DONE;
  })



;;-------------------------------------
;; Signed div/mod.  Native method is unsigned so record the sign of the result
;; by xor'ing operands together to examine highest bit.  Then take abs of operands.
;; Correct the sign of the quotient after the operation
(define_expand "divmodqi4"
  [(parallel [
     (set (match_operand:QI 0 "register_operand" "=r,r")
          (div:QI (match_operand:QI 1 "register_operand" "0,0")
                  (match_operand:QI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:QI 3 "register_operand" "=r,r")
          (mod:QI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("divmodqi4", operands, 4);
    tms9900_inline_debug ("; divmodqi4 alt=%d\n", which_alternative);

    /* Find quotient sign */
    rtx sign = gen_reg_rtx (HImode); // sign of quotient
    emit_insn(gen_extendqihi2 (operands[1], sign));
    // emit_move_insn(sign, operands[1]);
    emit_insn(gen_extendqihi2 (operands[2], operands[2]));
    emit_insn(gen_xorhi3(sign, sign, operands[2]));

    /* Use temp for operand2 and get abs value */
    rtx divisor = gen_reg_rtx (HImode);
    emit_move_insn(divisor, operands[2]);
    emit_insn(gen_abshi2(divisor, divisor));

    /* Use temp for operand1, get absolute value and extend to SI.  We don't
     * have abssi2 so do abs on a tmp before extend  */
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_abshi2(tmp, tmp));
    emit_insn(gen_extendhisi2 (dividend, tmp));

    /* Perform division and modulus */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));

    /* Convert and store quotient from HI to QI */
    rtx quotient = gen_reg_rtx (HImode);
    emit_move_insn (quotient, gen_highpart (HImode, dividend));

    /* Correct sign of quotient */
    emit_insn(gen_divfixuphi2(quotient, sign));

    /* Convert and store quotient from HI to QI */
    emit_insn(gen_trunchiqi2 (operands[0], quotient));

    /* Convert and store remainder from HI to QI */
    rtx remainder = gen_reg_rtx (HImode);
    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[3], remainder));

    DONE;
  }
)


(define_expand "divmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("divmodhi4", operands, 4);
    tms9900_inline_debug ("; divmodhi4 alt=%d\n", which_alternative);
    // rtx insn, div_equal, mod_equal, equal;

    /* Find quotient sign */
    rtx sign = gen_reg_rtx (HImode); // sign of quotient
    emit_move_insn(sign, operands[1]);
    emit_insn(gen_xorhi3(sign, sign, operands[2]));

    /* Use temp for operand2 and get abs value */
    rtx divisor = gen_reg_rtx (HImode);
    emit_move_insn(divisor, operands[2]);
    emit_insn(gen_abshi2(divisor, divisor));

    /* Use temp for operand1, get absolute value and extend to SI.  We don't
     * have abssi2 so do abs on a tmp before extend  */
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_abshi2(tmp, tmp));
    emit_insn(gen_extendhisi2 (dividend, tmp));

    /* Perform division and modulus */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));

    /* Correct sign of quotient */
    emit_insn(gen_divfixuphi2(operands[0], sign));

    DONE;
  }
)


;;-------------------------------------------------------------------
;; Divide and Modulus
;; native method HI = SI / HI , HI = SI % HI
;;-------------------------------------
(define_insn "udivmodsihi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (ior:SI
          (ashift:SI
            (zero_extend:SI
              (div:HI (match_operand:SI 1 "register_operand" "0,0")
                      (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
            (const_int 16))
          (zero_extend:SI 
            (mod:HI (match_dup 1)
                    (match_dup 2)))))]
  ""
  {
    tms9900_debug_operands ("udivmodsihi3", operands, 3);
    output_asm_insn ("div  %2, %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])



(define_insn "divfixuphi2"
  [(set (match_operand:HI 1 "register_operand" "=r")
        (not:HI (match_dup 1)))
   (set (match_operand:HI 0 "register_operand" "=r")
        (if_then_else:HI (lt:HI (match_dup 1) (const_int 0))
           (neg:HI (match_dup 0)) (match_dup 0)))]
  ""
  {
    tms9900_debug_operands ("divfixuphi2", operands, 2);
    output_asm_insn("inv  %1", operands);
    output_asm_insn("jlt  $+4", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])




;;-------------------------------------------------------------------
;; Absolute Value


;;-------------------------------------
(define_insn "abshi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (abs:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("abshi2", operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO not safe for byte operations, but limited to r onyl for now
;; TO do bytes would need to declare a scratch - maybe overkill
(define_insn "absqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
        (abs:QI (match_operand:QI 1 "register_operand" "0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("absqi2", operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Negate

;;-------------------------------------
(define_insn "neghi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (neg:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("neghi2", operands, 2);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO andi only reqiured for strict
(define_insn "negqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
        (neg:QI (match_operand:QI 1 "register_operand" "0")))
   (clobber (reg:CC CC_REGNUM))]
  ""
  {
    tms9900_debug_operands ("negqi2", operands, 2);
    output_asm_insn("andi %0, 0xFF00", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Other Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; No-op
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])



