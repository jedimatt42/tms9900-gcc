/* This file is is generated by a shell script.  DO NOT EDIT! */

/* emulate the original gld for the given tms9900
   Copyright 1991, 1992, 1994, 1996, 1999, 2000, 2001, 2002, 2003, 2004,
   2007 Free Software Foundation, Inc.
   Written by Steve Chamberlain steve@cygnus.com

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define TARGET_IS_tms9900

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"

#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"


static void
gldtms9900_before_parse (void)
{
#ifndef TARGET_			/* I.e., if not generic.  */
  ldfile_set_output_arch ("tms9900", bfd_arch_unknown);
#endif /* not TARGET_ */
}


static char *
gldtms9900_get_script (int *isfile)
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
"/* Script for ld -Ur: link w/out relocation, do create constructors */\n\
OUTPUT_FORMAT(\"elf32-tms9900\", \"elf32-tms9900\",\n\
	      \"elf32-tms9900\")\n\
OUTPUT_ARCH(tms9900)\n\
 /* For some reason, the Solaris linker makes bad executables\n\
  if gld -r is used and the intermediate file has sections starting\n\
  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld\n\
  bug.  But for now assigning the zero vmas works.  */\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  .interp       0 : { *(.interp) }\n\
  .note.gnu.build-id : { *(.note.gnu.build-id) }\n\
  .hash         0 : { *(.hash) }\n\
  .gnu.hash     0 : { *(.gnu.hash) }\n\
  .dynsym       0 : { *(.dynsym) }\n\
  .dynstr       0 : { *(.dynstr) }\n\
  .gnu.version  0 : { *(.gnu.version) }\n\
  .gnu.version_d 0: { *(.gnu.version_d) }\n\
  .gnu.version_r 0: { *(.gnu.version_r) }\n\
  .rel.init     0 : { *(.rel.init) }\n\
  .rela.init    0 : { *(.rela.init) }\n\
  .rel.text     0 : { *(.rel.text) }\n\
  .rela.text    0 : { *(.rela.text) }\n\
  .rel.fini     0 : { *(.rel.fini) }\n"
"  .rela.fini    0 : { *(.rela.fini) }\n\
  .rel.rodata   0 : { *(.rel.rodata) }\n\
  .rela.rodata  0 : { *(.rela.rodata) }\n\
  .rel.data.rel.ro 0 : { *(.rel.data.rel.ro) }\n\
  .rela.data.rel.ro 0 : { *(.rela.data.rel.ro) }\n\
  .rel.data     0 : { *(.rel.data) }\n\
  .rela.data    0 : { *(.rela.data) }\n\
  .rel.tdata	0 : { *(.rel.tdata) }\n\
  .rela.tdata	0 : { *(.rela.tdata) }\n\
  .rel.tbss	0 : { *(.rel.tbss) }\n\
  .rela.tbss	0 : { *(.rela.tbss) }\n\
  .rel.ctors    0 : { *(.rel.ctors) }\n\
  .rela.ctors   0 : { *(.rela.ctors) }\n\
  .rel.dtors    0 : { *(.rel.dtors) }\n\
  .rela.dtors   0 : { *(.rela.dtors) }\n\
  .rel.got      0 : { *(.rel.got) }\n\
  .rela.got     0 : { *(.rela.got) }\n\
  .rel.sdata    0 : { *(.rel.sdata) }\n\
  .rela.sdata   0 : { *(.rela.sdata) }\n\
  .rel.sbss     0 : { *(.rel.sbss) }\n\
  .rela.sbss    0 : { *(.rela.sbss) }\n\
  .rel.sdata2   0 : { *(.rel.sdata2) }\n\
  .rela.sdata2  0 : { *(.rela.sdata2) }\n\
  .rel.sbss2    0 : { *(.rel.sbss2) }\n\
  .rela.sbss2   0 : { *(.rela.sbss2) }\n"
"  .rel.bss      0 : { *(.rel.bss) }\n\
  .rela.bss     0 : { *(.rela.bss) }\n\
  .rel.plt      0 : { *(.rel.plt) }\n\
  .rela.plt     0 : { *(.rela.plt) }\n\
  .init         0 :\n\
  {\n\
    KEEP (*(.init))\n\
  } =0\n\
  .plt          0 : { *(.plt) }\n\
  .text         0 :\n\
  {\n\
    *(.text .stub)\n\
    /* .gnu.warning sections are handled specially by elf32.em.  */\n\
    *(.gnu.warning)\n\
  } =0\n\
  .fini         0 :\n\
  {\n\
    KEEP (*(.fini))\n\
  } =0\n\
  .rodata       0 : { *(.rodata) }\n\
  .rodata1      0 : { *(.rodata1) }\n\
  .sdata2       0 :\n\
  {\n\
    *(.sdata2)\n\
  }\n"
"  .sbss2        0 : { *(.sbss2) }\n\
  .eh_frame_hdr : { *(.eh_frame_hdr) }\n\
  .eh_frame     0 : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table 0 : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  /* Exception handling  */\n\
  .eh_frame     0 : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table 0 : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	0 : { *(.tdata) }\n\
  .tbss		0 : { *(.tbss) }\n\
  .preinit_array   0 :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array   0 :\n\
  {\n\
     KEEP (*(SORT(.init_array.*)))\n\
     KEEP (*(.init_array))\n\
  }\n\
  .fini_array   0 :\n\
  {\n\
    KEEP (*(.fini_array))\n\
    KEEP (*(SORT(.fini_array.*)))\n"
"  }\n\
  .jcr          0 : { KEEP (*(.jcr)) }\n\
  .dynamic      0 : { *(.dynamic) }\n\
  .data         0 :\n\
  {\n\
    *(.data)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1        0 : { *(.data1) }\n\
  .got          0 : { *(.got.plt) *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata        0 :\n\
  {\n\
    *(.sdata)\n\
  }\n\
  .sbss         0 :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss)\n\
    *(.scommon)\n\
  }\n\
  .bss          0 :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we don't\n\
      pad the .data section.  */\n\
  }\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1 */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2 */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2 */\n\
  .debug_info     0 : { *(.debug_info) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3 */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
}\n\n"
  ; else if (link_info.relocatable) return
"/* Script for ld -r: link without relocation */\n\
OUTPUT_FORMAT(\"elf32-tms9900\", \"elf32-tms9900\",\n\
	      \"elf32-tms9900\")\n\
OUTPUT_ARCH(tms9900)\n\
 /* For some reason, the Solaris linker makes bad executables\n\
  if gld -r is used and the intermediate file has sections starting\n\
  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld\n\
  bug.  But for now assigning the zero vmas works.  */\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  .interp       0 : { *(.interp) }\n\
  .note.gnu.build-id : { *(.note.gnu.build-id) }\n\
  .hash         0 : { *(.hash) }\n\
  .gnu.hash     0 : { *(.gnu.hash) }\n\
  .dynsym       0 : { *(.dynsym) }\n\
  .dynstr       0 : { *(.dynstr) }\n\
  .gnu.version  0 : { *(.gnu.version) }\n\
  .gnu.version_d 0: { *(.gnu.version_d) }\n\
  .gnu.version_r 0: { *(.gnu.version_r) }\n\
  .rel.init     0 : { *(.rel.init) }\n\
  .rela.init    0 : { *(.rela.init) }\n\
  .rel.text     0 : { *(.rel.text) }\n\
  .rela.text    0 : { *(.rela.text) }\n\
  .rel.fini     0 : { *(.rel.fini) }\n"
"  .rela.fini    0 : { *(.rela.fini) }\n\
  .rel.rodata   0 : { *(.rel.rodata) }\n\
  .rela.rodata  0 : { *(.rela.rodata) }\n\
  .rel.data.rel.ro 0 : { *(.rel.data.rel.ro) }\n\
  .rela.data.rel.ro 0 : { *(.rela.data.rel.ro) }\n\
  .rel.data     0 : { *(.rel.data) }\n\
  .rela.data    0 : { *(.rela.data) }\n\
  .rel.tdata	0 : { *(.rel.tdata) }\n\
  .rela.tdata	0 : { *(.rela.tdata) }\n\
  .rel.tbss	0 : { *(.rel.tbss) }\n\
  .rela.tbss	0 : { *(.rela.tbss) }\n\
  .rel.ctors    0 : { *(.rel.ctors) }\n\
  .rela.ctors   0 : { *(.rela.ctors) }\n\
  .rel.dtors    0 : { *(.rel.dtors) }\n\
  .rela.dtors   0 : { *(.rela.dtors) }\n\
  .rel.got      0 : { *(.rel.got) }\n\
  .rela.got     0 : { *(.rela.got) }\n\
  .rel.sdata    0 : { *(.rel.sdata) }\n\
  .rela.sdata   0 : { *(.rela.sdata) }\n\
  .rel.sbss     0 : { *(.rel.sbss) }\n\
  .rela.sbss    0 : { *(.rela.sbss) }\n\
  .rel.sdata2   0 : { *(.rel.sdata2) }\n\
  .rela.sdata2  0 : { *(.rela.sdata2) }\n\
  .rel.sbss2    0 : { *(.rel.sbss2) }\n\
  .rela.sbss2   0 : { *(.rela.sbss2) }\n"
"  .rel.bss      0 : { *(.rel.bss) }\n\
  .rela.bss     0 : { *(.rela.bss) }\n\
  .rel.plt      0 : { *(.rel.plt) }\n\
  .rela.plt     0 : { *(.rela.plt) }\n\
  .init         0 :\n\
  {\n\
    KEEP (*(.init))\n\
  } =0\n\
  .plt          0 : { *(.plt) }\n\
  .text         0 :\n\
  {\n\
    *(.text .stub)\n\
    /* .gnu.warning sections are handled specially by elf32.em.  */\n\
    *(.gnu.warning)\n\
  } =0\n\
  .fini         0 :\n\
  {\n\
    KEEP (*(.fini))\n\
  } =0\n\
  .rodata       0 : { *(.rodata) }\n\
  .rodata1      0 : { *(.rodata1) }\n\
  .sdata2       0 :\n\
  {\n\
    *(.sdata2)\n\
  }\n"
"  .sbss2        0 : { *(.sbss2) }\n\
  .eh_frame_hdr : { *(.eh_frame_hdr) }\n\
  .eh_frame     0 : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table 0 : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  /* Exception handling  */\n\
  .eh_frame     0 : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table 0 : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	0 : { *(.tdata) }\n\
  .tbss		0 : { *(.tbss) }\n\
  .preinit_array   0 :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array   0 :\n\
  {\n\
     KEEP (*(SORT(.init_array.*)))\n\
     KEEP (*(.init_array))\n\
  }\n\
  .fini_array   0 :\n\
  {\n\
    KEEP (*(.fini_array))\n\
    KEEP (*(SORT(.fini_array.*)))\n"
"  }\n\
  .jcr          0 : { KEEP (*(.jcr)) }\n\
  .dynamic      0 : { *(.dynamic) }\n\
  .data         0 :\n\
  {\n\
    *(.data)\n\
  }\n\
  .data1        0 : { *(.data1) }\n\
  .got          0 : { *(.got.plt) *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata        0 :\n\
  {\n\
    *(.sdata)\n\
  }\n\
  .sbss         0 :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss)\n\
    *(.scommon)\n\
  }\n\
  .bss          0 :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we don't\n\
      pad the .data section.  */\n\
  }\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1 */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2 */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2 */\n\
  .debug_info     0 : { *(.debug_info) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3 */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
}\n\n"
  ; else if (!config.text_read_only) return
"/* Script for -N: mix text and data on same page; don't align data */\n\
OUTPUT_FORMAT(\"elf32-tms9900\", \"elf32-tms9900\",\n\
	      \"elf32-tms9900\")\n\
OUTPUT_ARCH(tms9900)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"/home/mark/tms9900-gcc/tms9900/tms9900/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = 0xA000); . = 0xA000 + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n"
"  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n\
  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n\
  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n"
"  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.plt        : { *(.rel.plt) }\n\
  .rela.plt       : { *(.rela.plt) }\n\
  .init           :\n\
  {\n\
    KEEP (*(.init))\n\
  } =0\n\
  .plt            : { *(.plt) }\n\
  .text           :\n\
  {\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf32.em.  */\n\
    *(.gnu.warning)\n\
  } =0\n\
  .fini           :\n\
  {\n\
    KEEP (*(.fini))\n\
  } =0\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n"
"    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr : { *(.eh_frame_hdr) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = .;\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  : { *(.tdata .tdata.* .gnu.linkonce.td.*) }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array     :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array     :\n\
  {\n\
     PROVIDE_HIDDEN (__init_array_start = .);\n\
     KEEP (*(SORT(.init_array.*)))\n"
"     KEEP (*(.init_array))\n\
     PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array     :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(.fini_array))\n\
    KEEP (*(SORT(.fini_array.*)))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  .got            : { *(.got.plt) *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  _edata = .; PROVIDE (edata = .);\n\
  __bss_start = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we don't\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1 */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2 */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2 */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3 */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) }\n\
}\n\n"
  ; else if (!config.magic_demand_paged) return
"/* Script for -n: mix text and data on same page */\n\
OUTPUT_FORMAT(\"elf32-tms9900\", \"elf32-tms9900\",\n\
	      \"elf32-tms9900\")\n\
OUTPUT_ARCH(tms9900)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"/home/mark/tms9900-gcc/tms9900/tms9900/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = 0xA000); . = 0xA000 + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n"
"  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n\
  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n\
  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n"
"  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.plt        : { *(.rel.plt) }\n\
  .rela.plt       : { *(.rela.plt) }\n\
  .init           :\n\
  {\n\
    KEEP (*(.init))\n\
  } =0\n\
  .plt            : { *(.plt) }\n\
  .text           :\n\
  {\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf32.em.  */\n\
    *(.gnu.warning)\n\
  } =0\n\
  .fini           :\n\
  {\n\
    KEEP (*(.fini))\n\
  } =0\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n"
"    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr : { *(.eh_frame_hdr) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = ALIGN(512) + (. & ( - 1));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  : { *(.tdata .tdata.* .gnu.linkonce.td.*) }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array     :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array     :\n\
  {\n\
     PROVIDE_HIDDEN (__init_array_start = .);\n\
     KEEP (*(SORT(.init_array.*)))\n"
"     KEEP (*(.init_array))\n\
     PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array     :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(.fini_array))\n\
    KEEP (*(SORT(.fini_array.*)))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  .got            : { *(.got.plt) *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  _edata = .; PROVIDE (edata = .);\n\
  __bss_start = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we don't\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1 */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2 */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2 */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3 */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) }\n\
}\n\n"
  ; else return
"/* Default linker script, for normal executables */\n\
OUTPUT_FORMAT(\"elf32-tms9900\", \"elf32-tms9900\",\n\
	      \"elf32-tms9900\")\n\
OUTPUT_ARCH(tms9900)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"/home/mark/tms9900-gcc/tms9900/tms9900/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = 0xA000); . = 0xA000 + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n"
"  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n\
  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n\
  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n"
"  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.plt        : { *(.rel.plt) }\n\
  .rela.plt       : { *(.rela.plt) }\n\
  .init           :\n\
  {\n\
    KEEP (*(.init))\n\
  } =0\n\
  .plt            : { *(.plt) }\n\
  .text           :\n\
  {\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf32.em.  */\n\
    *(.gnu.warning)\n\
  } =0\n\
  .fini           :\n\
  {\n\
    KEEP (*(.fini))\n\
  } =0\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n"
"    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr : { *(.eh_frame_hdr) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = ALIGN(512) + (. & ( - 1));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  : { *(.tdata .tdata.* .gnu.linkonce.td.*) }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array     :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array     :\n\
  {\n\
     PROVIDE_HIDDEN (__init_array_start = .);\n\
     KEEP (*(SORT(.init_array.*)))\n"
"     KEEP (*(.init_array))\n\
     PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array     :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(.fini_array))\n\
    KEEP (*(SORT(.fini_array.*)))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  .got            : { *(.got.plt) *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  _edata = .; PROVIDE (edata = .);\n\
  __bss_start = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we don't\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1 */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2 */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2 */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3 */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) }\n\
}\n\n"
; }

struct ld_emulation_xfer_struct ld_tms9900_emulation =
{
  gldtms9900_before_parse,
  syslib_default,
  hll_default,
  after_parse_default,
  after_open_default,
  after_allocation_default,
  set_output_arch_default,
  ldemul_default_target,
  before_allocation_default,
  gldtms9900_get_script,
  "tms9900",
  "elf32-tms9900",
  finish_default,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,	/* add_options */
  NULL,	/* handle_option */
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
};
