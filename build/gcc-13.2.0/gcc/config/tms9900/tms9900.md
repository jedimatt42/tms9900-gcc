;;- Machine description for the tms9900 for GNU C compiler
;; Copyright (C) 2010-2023 Free Software Foundation, Inc.
;; Contributed by Eric Welser and Mark Burkley (mark@burkley.net)

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

(include "constraints.md")

(define_constants
  [
   ;; Register numbers
   (R0_REGNUM     	  0)
   (R1_REGNUM     	  1)
   (R2_REGNUM     	  2)
   (R3_REGNUM     	  3)
   (R4_REGNUM     	  4)
   (R5_REGNUM     	  5)
   (R6_REGNUM     	  6)
   (R7_REGNUM     	  7)
   (R8_REGNUM     	  8)
   (R9_REGNUM     	  9)
   (R10_REGNUM     	  10)
   (R11_REGNUM     	  11)
   (R12_REGNUM     	  12)
   (R13_REGNUM     	  13)
   (R14_REGNUM     	  14)
   (R15_REGNUM     	  15)

   ;; ST, WP and PC are given pseudo reg numbers here too
   ;; Status register
   (ST_REGNUM	   	  16)
   ;; Workspace pointer
   (WP_REGNUM		  17)
   ;; Workspace pointer
   (PC_REGNUM		  18)

   ;; Several regs have alternate uses, define them here
   ;; Shift count register
   (SC_REGNUM     	  0)
   (RETVAL_REGNUM     	  1)
   (ARG_POINTER_REGNUM	  8)
   (FRAME_POINTER_REGNUM  9)
   (STACK_POINTER_REGNUM  10)
   ;; Old PC after BL instruction
   (LR_REGNUM		  11)
   ;; CRU base address
   (CB_REGNUM		  12)
   ;; Old workspace after BLWP instruction
   (LW_REGNUM		  13)
   ;; Old PC after BLWP instruction
   (LP_REGNUM		  14)
   ;; Old status register after BLWP instruction
   (LS_REGNUM		  15)
   ;; Condition code registers
   (CC_REGNUM             16)
   ;; End of hard registers
   (FIRST_PSEUDO_REGISTER 19)
   
   ;; Branch offset limits, as byte offsets from (pc).
   ;; TODO check these are valid for tms9900
   (MIN_BRANCH            -254)
   (MAX_BRANCH            254)])

;; SI is 32 bit
;; HI is 16 bit
;; QI is 8 bit 

;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.

;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
;;- updates for most instructions.

;;- Operand classes for the register allocator:

;; Compare instructions.


;; define attributes
;; currently type is only fpu or arith or unknown, maybe branch later ?
;; default is arith
(define_attr "type" "unknown,arith,fp" (const_string "arith"))

;; length default is 1 word each
;; MGB TODO is length bytes or words?
(define_attr "length" "" (const_int 1))

;; a user's asm statement
(define_asm_attributes
  [(set_attr "type" "unknown")
; all bets are off how long it is - make it 256, forces long jumps 
; whenever jumping around it !!!
   (set_attr "length" "256")])

;; MGB To address the issue where tms9900 stores bytes in the MSB position, all
;; QI loads to registers are right-shifted 8 bits before storage as a HI value

;;-------------------------------------------------------------------
;;  UNSPEC Definitions
;;-------------------------------------------------------------------
(define_constants
  [(UNSPEC_RETURN  0)])


;;-------------------------------------------------------------------
;;  Predicate Definitions
;;-------------------------------------------------------------------

(define_predicate "shift_count_operand"
  (ior (match_code "const_int")
       (match_code "reg")))


;;-------------------------------------------------------------------
;;  Function Calls
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Jump to a subroutine which returns a value
(define_insn "call"
  [(call (match_operand:HI 0 "general_operand" "rR,Q")
         (match_operand:HI 1 "general_operand"  "g,g"))
  ]
  ""
  {
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %0", operands);
    else
      output_asm_insn("bl   %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)


;-------------------------------------------------------------------
; Jump to a subroutine which returns a value
(define_insn "call_value"
  [(set (match_operand 0 "" "")
        (call (match_operand:HI 1 "general_operand" "rR,Q")
	      (match_operand:HI 2 "general_operand" "g,g")))
  ]
  ""
  {
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %1", operands);
    else
      output_asm_insn("bl   %1", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)


;;-------------------------------------------------------------------
;; Define function prologue
(define_expand "prologue"
  [(const_int 0)]
  ""
{
  tms9900_expand_prologue();
  DONE;
})


;;-------------------------------------------------------------------
;; Define function epilogue
(define_expand "epilogue"
  [(return)]
  ""
{
  tms9900_expand_epilogue(false);
  DONE;
})

(define_expand "sibcall_epilogue"
  [(return)]
  ""
{
  tms9900_expand_epilogue(true);
  DONE;
})


;;-------------------------------------------------------------------
;; Define function return
(define_insn "*rt"
  [(unspec [(match_operand:HI 0 "general_operand" "")] UNSPEC_RETURN)]
  ""
  "b    *r11"
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Comparison Instructions
;;-------------------------------------------------------------------

;; TODO cc0 deprecated https://gcc.gnu.org/wiki/CC0Transition
;; find-and-replace cc0 with reg:CC HARD_ST_REGNUM for now

;;-------------------------------------
;; (define_insn "tsthi"
;;   [(set (reg:CC CC_REGNUM)
;; 	(match_operand:HI 0 "nonimmediate_operand" "rR,Q"))]
;;   ""
;;   {
;;     tms9900_debug_operands ("tsthi", operands, 1);
;;     return("mov  %0, %0");
;;   }
;;   [(set_attr "length" "2,6")])


;;-------------------------------------
;; (define_insn "tstqi"
;;   [(set (reg:CC CC_REGNUM)
;; 	(match_operand:QI 0 "nonimmediate_operand" "rR,Q"))]
;;   ""
;;   {
;;     tms9900_debug_operands ("tstqi", operands, 1);
;;     return("movb %0, %0");
;;   }
;;   [(set_attr "length" "2,6")])
 

;;-------------------------------------
(define_insn "cmphi"
  [(set (reg:CC CC_REGNUM)
	(compare:CC (match_operand:HI 0 "nonimmediate_operand" "rR,rR,Q,Q,r")
                    (match_operand:HI 1 "general_operand"      "rR,Q,rR,Q,i")))]
  ""
  {
    tms9900_debug_operands ("cmphi", operands, 2);
    if (which_alternative == 4)
    {
       return("ci   %0, %1");
    }
    else
    {
      return("c    %0, %1");
    }
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------
(define_insn "cmpqi"
  [(set (reg:CC CC_REGNUM)
	(compare:CC (match_operand:QI 0 "register_operand" "r,r,r,r")
		 (match_operand:QI 1 "general_operand" "r,R,Q,i")))]
  ""
  {
    tms9900_debug_operands ("cmpqi", operands, 2);
    switch (which_alternative)
    {
    case 0:
      // output_asm_insn("c    %0, %1",  operands);
      // break;
    case 1:
    case 2:
      // output_asm_insn("swpb %0",  operands);
      output_asm_insn("cb   %0, %1",  operands);
      // output_asm_insn("swpb %0",  operands);
      break;
    case 3:
      // TODO misaligned here.  And what if low byt of %0 contains junk?
      output_asm_insn("ci   %0, %1",  operands);
      break;
    }
    return("");
  }
  [(set_attr "length" "2,6,8,4")])

;;-------------------------------------------------------------------
;;  Move Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Move byte value
(define_insn "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,R>,Q,r,R>,Q,r,R>,Q,r")
        (match_operand:QI 1 "general_operand" "r,r,r,R>,R>,R>,Q,Q,Q,i"))]
  ""
  {
    tms9900_debug_operands ("movqi", operands, 2);
    // tms9900_register_convert (operands[1], QImode, 0);
    // tms9900_register_mode_set (operands[0], QImode);
    int val;
    switch(which_alternative)
    {
    case 0:
      output_asm_insn("mov  %1, %0", operands);
      break;
    case 1:
    case 2:
      // output_asm_insn("swpb %1", operands);
      output_asm_insn("movb %1, %0", operands);
      // output_asm_insn("swpb %1", operands);
      break;
    case 3:
    case 6:
      /*  TODO It MIGHT be cheaper to do CLR,MOVB,SWPB */
      output_asm_insn("movb %1, %0", operands);
      // output_asm_insn("srl %0, 8", operands);
      break;
    case 4:
    case 5:
    case 7:
    case 8:
      output_asm_insn("movb %1, %0", operands);
      break;
    case 9:
      val = INTVAL(operands[1]);
      if (INTVAL(operands[1]) == 0)
        return("clr  %0");
      else if (INTVAL(operands[1]) == -1)
        return("seto %0");
      else
      {
        // TODO mult by 256
        tms9900_inline_debug ("; movqi imm MUL const %d * 256\n", val);
        operands[1] = GEN_INT(val*256);
        return("li   %0, %1");
      }
      break;
    }
    return("");
  }
  [(set_attr "length" "2,6,8,4,2,4,4,2,4,4")])



;; MGB TODO use which_alt for consistency
;;-------------------------------------------------------------------
;; Move two-byte value
(define_insn "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,r")
	(match_operand:HI 1 "general_operand" "rROM>,Q,rROM>,Q,i,r"))]
  ""
  {
    tms9900_debug_operands ("movhi", operands, 2);
    tms9900_register_convert (operands[1], HImode, 0);
    tms9900_register_mode_set (operands[0], HImode);
    switch(GET_CODE(operands[1]))
    {
      case CONST_INT:
        if (INTVAL(operands[1]) == 0)
          return("clr  %0");
        else if (INTVAL(operands[1]) == -1)
          return("seto %0");
        else
          return("li   %0, %1");

      case REG:
        output_asm_insn("mov  %1, %0", operands);

        if (ORIGINAL_REGNO (operands[1]) != REGNO (operands[1]))
        {
            tms9900_inline_debug ("; movhi = orig differs by %d\n",
                (int) REG_OFFSET (operands[1]));

            /*  This is a case where for some reason gcc has matched a HI
             *  predicate using a QI parameter and has not matched an extend
             *  predicate to do the conversion.  We can detect this case by
             *  noticing the reg has an offset of -1.  Fix it by emitting a srl.
             */
            if ((int) REG_OFFSET (operands[1]) == -1)
            {
                tms9900_inline_debug ("; NOT a HI, emit shift\n");
                output_asm_insn("srl  %0, 8", operands);
            }
        }
        return ("");
      case MEM:
        return("mov  %1, %0");

      default:
        return("li   %0, %1");
    }
  }
  [(set_attr "length" "2,4,4,6,4,2")])

;;-------------------------------------------------------------------
;; Move four-byte value
(define_insn "movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,r")
	(match_operand:SI 1 "general_operand" "rROM>,Q,rROM>,Q,i,r"))]
  ""
  {
    tms9900_debug_operands ("movsi", operands, 2);
    // tms9900_register_convert (operands[1], HImode, 0);
    // tms9900_register_mode_set (operands[0], HImode);
    switch(GET_CODE(operands[1]))
    {
      case CONST_INT:
        if (INTVAL(operands[1]) == 0)
        {
          return("clr  %0");
          // TODO clr %0 + 1
        }
        else if (INTVAL(operands[1]) == -1)
        {
          return("seto %0");
          // TODO seto %0 + 1
        }
        else
        {
          return("li   %0, %1");
          // TODO li %0 + 1 with %1 >> 16
        }

      case REG:
      case MEM:
        return("mov  %1, %0");
        // TODO move high word

      default:
        return("li   %0, %1");
        // TODO rearrange and fall thru
    }
  }
  [(set_attr "length" "2,4,4,6,4,2")])


;;-------------------------------------------------------------------
;; Type Conversions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Zero Extend
;;-------------------------------------

(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(zero_extend:HI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("zero_extendqihi2", operands, 2);
    output_asm_insn ("srl  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------
(define_insn "zero_extendqisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,R,Q")
	(zero_extend:SI (match_operand:QI 1 "general_operand" "g,g,g")))]
  ""
  {
    tms9900_debug_operands ("zero_extendqisi2", operands, 2);
    rtx lateoperands[2];

    lateoperands[0] = operands[0];
    if (REG_P (operands[0]))
    {
      tms9900_inline_debug ("; %%0 is now HI of r%d+%d\n", REGNO
                          (operands[0]),REGS_PER_WORD);
      operands[0] = gen_rtx_REG(HImode, REGNO(operands[0]) + REGS_PER_WORD);
    }
    else
    {
      tms9900_inline_debug ("; %%0 is now HI with adj_addr 2\n");
      operands[0] = adjust_address(operands[0], HImode, 2);
    }

    output_asm_insn("srl  %0, 8", operands);
    output_asm_insn("mov  %1, %0", operands);
    output_asm_insn("clr  %0", lateoperands);
    return("");
  }
  [(set_attr "length" "4,8,10")])

(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,R,Q")
	(zero_extend:SI (match_operand:HI 1 "general_operand" "g,g,g")))]
  ""
  {
    tms9900_debug_operands ("zero_extendhisi2", operands, 2);
    #if 1
    rtx lateoperands[2];

    lateoperands[0] = operands[0];
    if (REG_P (operands[0]))
    {
      tms9900_inline_debug ("; %%0 is now HI of r%d+%d\n", REGNO
                          (operands[0]),REGS_PER_WORD);
      operands[0] = gen_rtx_REG(HImode, REGNO(operands[0]) + REGS_PER_WORD);
    }
    else
    {
      tms9900_inline_debug ("; %% is now HI with adj_addr 2\n");
      operands[0] = adjust_address(operands[0], HImode, 2);
    }

    output_asm_insn("mov  %1, %0", operands);
    output_asm_insn("clr  %0", lateoperands);
    #endif
    return("");
  }
  [(set_attr "length" "4,8,10")])


;;-------------------------------------------------------------------
;; Sign Extend
;;-------------------------------------------------------------------

(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("extendqihi2", operands, 2);
    // output_asm_insn("swpb %0", operands);
    output_asm_insn("sra  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2")])
			 

(define_insn "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(sign_extend:SI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("extendqisi2", operands, 2);
    // output_asm_insn("swpb %0", operands);
    output_asm_insn("sra  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2")])
			 

;;-------------------------------------
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,R,Q")
	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,g,g")))]
  ""
  {
    tms9900_debug_operands ("extendhisi2", operands, 2);
    rtx latehalf[2];
    rtx offset[2];

    latehalf[0] = operands[0];
    if (REG_P (operands[0]))
    {
      tms9900_inline_debug ("; %%0 is now HI of r%d+%d\n", REGNO
                          (operands[0]),REGS_PER_WORD);
      operands[0] = gen_rtx_REG(HImode, REGNO(operands[0]) + REGS_PER_WORD);
    }
    else
    {
      tms9900_inline_debug ("; %% is now HI with adj_addr 2\n");
      operands[0] = adjust_address(operands[0], HImode, 2);
    }

    if(which_alternative == 2)
      offset[0] = GEN_INT(6);
    else
      offset[0] = GEN_INT(4);

    output_asm_insn("mov  %1, %0", operands);
    output_asm_insn("seto %0", latehalf);
    output_asm_insn("jlt  $+%0", offset);
    output_asm_insn("clr  %0", latehalf);
    return("");
  }
  [(set_attr "length" "8,12,14")])

;;-------------------------------------------------------------------
;; Truncate
;;-------------------------------------

(define_insn "trunchiqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(truncate:QI (match_operand:HI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("zero_trunchiqi2", operands, 2);
    output_asm_insn ("sla  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2")])

(define_insn "truncsiqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(truncate:QI (match_operand:SI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("zero_truncsiqi2", operands, 2);
    output_asm_insn ("sla  %0, 8", operands);
    // TODO any action needed to discard high word?
    return("");
  }
  [(set_attr "length" "2")])

(define_insn "truncsihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(truncate:HI (match_operand:SI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("zero_truncsihi2", operands, 2);
    // TODO any action needed to discard high word?
    return("");
  }
  [(set_attr "length" "2")])

;;-------------------------------------------------------------------
;;  Branch Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Jump if equal
(define_insn "beq"
  [(set (pc)
	(if_then_else (eq (reg:CC CC_REGNUM)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    return(output_branch("jeq", "jne", get_attr_length(insn)));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if equal, reversed comparison operands
(define_insn "*beq_reversed"
  [(set (pc)
	(if_then_else (eq (reg:CC CC_REGNUM)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    return(output_branch("jne", "jeq", get_attr_length(insn)));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if not equal
(define_insn "bne"
  [(set (pc)
	(if_then_else (ne (reg:CC CC_REGNUM)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jne\", \"jeq\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if not equal, reversed comparison operands
(define_insn "*bne_reversed"
  [(set (pc)
	(if_then_else (ne (reg:CC CC_REGNUM)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jeq\", \"jne\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned less than
(define_insn "bltu"
  [(set (pc)
	(if_then_else (ltu (reg:CC CC_REGNUM)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jl\", \"jhe\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned less than, reversed comparison operands
(define_insn "*bltu_reversed"
  [(set (pc)
	(if_then_else (ltu (reg:CC CC_REGNUM)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jhe\", \"jl\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned less than or equal
(define_insn "bleu"
  [(set (pc)
	(if_then_else (leu (reg:CC CC_REGNUM)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jle\", \"jh\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned less than or equal, reversed comparison operands
(define_insn "*bleu_reversed"
  [(set (pc)
	(if_then_else (leu (reg:CC CC_REGNUM)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jh\", \"jle\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned greater than
(define_insn "bgtu"
  [(set (pc)
	(if_then_else (gtu (reg:CC CC_REGNUM)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jh\", \"jle\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned greater than, reversed comparison operands
(define_insn "*bgtu_reversed"
  [(set (pc)
	(if_then_else (gtu (reg:CC CC_REGNUM)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jle\", \"jh\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned greater than or equal
(define_insn "bgeu"
  [(set (pc)
	(if_then_else (geu (reg:CC CC_REGNUM)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jhe\", \"jl\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned greater than or equal, reversed comparison operands
(define_insn "*bgeu_reversed"
  [(set (pc)
	(if_then_else (geu (reg:CC CC_REGNUM)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jl\", \"jhe\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if less than
(define_insn "blt"
  [(set (pc)
	(if_then_else (lt (reg:CC CC_REGNUM)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jlt\", \"GE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if less than, reversed comparison operands
; Was commented out
(define_insn "*blt_reversed"
  [(set (pc)
	(if_then_else (lt (reg:CC CC_REGNUM)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"GE\", \"jlt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------------------------------------
;; Jump if less than or equal
(define_insn "ble"
  [(set (pc)
	(if_then_else (le (reg:CC CC_REGNUM)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"LE\", \"jgt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------
;; Jump if less than or equal, reversed comparison operands
(define_insn "*ble_reversed"
  [(set (pc)
	(if_then_else (le (reg:CC CC_REGNUM)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jgt\", \"LE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if greater than
(define_insn "bgt"
  [(set (pc)
	(if_then_else (gt (reg:CC CC_REGNUM)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jgt\", \"LE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if greater than, reversed comparison operands
; Was commented out
(define_insn "*bgt_reversed"
  [(set (pc)
	(if_then_else (gt (reg:CC CC_REGNUM)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"LE\", \"jgt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------------------------------------
;; Jump if greater than or equal
; Was commented out
(define_insn "bge"
  [(set (pc)
	(if_then_else (ge (reg:CC CC_REGNUM)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"GE\", \"jlt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------
;; Jump if greater than or equal, reversed comparison operands
(define_insn "*bge_reversed"
  [(set (pc)
	(if_then_else (ge (reg:CC CC_REGNUM)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jlt\", \"GE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;;  Jump Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Unconditional jump to label
(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "*
  return output_jump(get_attr_length(insn));"

  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 14)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Unconditional jump using pointer
(define_insn "indirect_jump"
  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "r,Q"))]
  ""
  "b    %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Unconditional jump using jump table
(define_insn "tablejump"
  [(clobber (match_scratch:HI 2 "=r,r"))
   (set (pc) (match_operand:HI 0 "nonimmediate_operand" "rR,Q"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  {
    output_asm_insn("mov  %0, %2", operands);
    output_asm_insn("b    *%2",    operands);
    return(""); 
  }
  [(set_attr "length" "4,6")])


;;-------------------------------------------------------------------
;;  Bit Shift Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Arithmetic shift left



;;-------------------------------------
(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(ashift:HI (match_operand:HI 1 "register_operand" "0,0")
		   (match_operand:HI 2 "shift_count_operand" "r,i")))]
  ""
  {
    tms9900_debug_operands ("ashlhi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",     operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sla  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sla  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(ashift:QI (match_operand:QI 1 "register_operand" "0,0")
		   (match_operand:HI 2 "shift_count_operand" "r,i")))]
  ""
  {
    tms9900_debug_operands ("ashlqi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",        operands);
      output_asm_insn("jeq  $+8",       operands);  /* If shift count is zero, do nothing */
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "10,6")])


;;-------------------------------------------------------------------
;; Arithmetic shift left (for QI mode)

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 2 "register_operand" "")
	(ashift:HI (match_dup 0)
                   (plus:HI (match_operand:HI 3 "const_int_operand" "")
                            (match_operand:HI 4 "const_int_operand" ""))))]
  ""
  [(set (match_dup 2)
        (match_dup 1))
   (set (match_dup 2)
        (ashift:QI (match_dup 2)
                   (match_dup 3)))]
  "")


;;-------------------------------------------------------------------
;; Arithmetic shift right


;;-------------------------------------
(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(ashiftrt:HI (match_operand:HI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "r,i")))]
  ""
  {
    tms9900_debug_operands ("ashrhi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",     operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sra  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sra  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "r,i")))]
  ""
  {
    tms9900_debug_operands ("ashrqi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",        operands);
      output_asm_insn("jeq  $+4",       operands);
      output_asm_insn("sra  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sra  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 3 "register_operand" "")
	(ashiftrt:HI (match_operand:HI 4 "register_operand" "")
		     (match_operand:HI 5 "shift_count_operand" "")))
   (set (match_operand:QI 6 "register_operand" "")
        (subreg:QI (match_operand:HI 7 "register_operand" "") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (ashiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  "")


;;-------------------------------------------------------------------
;; Logical shift right



;;-------------------------------------
(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "r,i")))]
  ""
  {
    tms9900_debug_operands ("lshrhi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",     operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("srl  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("srl  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "r,i")))]
  ""
  {
    tms9900_debug_operands ("lshrqi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",        operands);
      output_asm_insn("jeq  $+4",       operands);
      output_asm_insn("srl  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("srl  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 3 "register_operand" "")
	(lshiftrt:HI (match_operand:HI 4 "register_operand" "")
		     (match_operand:HI 5 "shift_count_operand" "")))
   (set (match_operand:QI 6 "register_operand" "")
        (subreg:QI (match_operand:HI 7 "register_operand" "") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (lshiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  "")
      


;;-------------------------------------------------------------------
;; Rotate 


;;-------------------------------------
(define_expand "rotlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "r,i")))]
  ""
  {
    tms9900_debug_operands ("rotlhi3", operands, 3);
    if (GET_CODE (operands[2]) == CONST_INT)
      operands[2] = GEN_INT ((16 - INTVAL (operands[2])) % 16);
    else
      {
        rtx reg = gen_reg_rtx (HImode);
        emit_insn (gen_subhi3 (reg, GEN_INT (16), operands[2]));
        operands[2] = reg;
      }
  })


;;-------------------------------------
(define_insn "rotrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "r,i")))]
  ""
  "@
  src  %0, 0
  src  %0, %2" 
 [(set_attr "length" "2,2")])


;;-------------------------------------------------------------------
;;  Bitwise Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; And


;;-------------------------------------
(define_insn "andhi3"
  [(clobber (match_scratch:HI 3 "=r,r,r,r,r,r,r"))
   (set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,R>,Q")
	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0,0,0,0")
		(match_operand:HI 2 "general_operand" "rR>,Q,rR>,Q,i,i,i")))]
  ""
  {
    tms9900_debug_operands ("andhi3", operands, 3);
    if(which_alternative >= 4)
    {
      int val = INTVAL(operands[2]) & 0xFFFF;
      if(val == 0)
      {
        /* Result will be zero */
        output_asm_insn("clr  %0", operands);
      }
      else if(val == 0xFFFF)
      {
        /* No operation required */
        return("");
      }
      else if(which_alternative == 4)
      {
        /* AND const value and register */
        output_asm_insn("andi %0, %2", operands);
      }
      else if(which_alternative >= 5)
      {
        /* AND const value and memory */
        operands[2] = GEN_INT(~val);
        output_asm_insn("li   %3, %2", operands);
        output_asm_insn("szc  %3, %0", operands);
      }
    }
    else
    {
      /* AND against non-const value */
      if(!rtx_equal_p(operands[2], operands[3]))
      {
        output_asm_insn("mov  %2, %3", operands);
      }
      output_asm_insn("inv  %3",     operands);
      output_asm_insn("szc  %3, %0", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,8,10,4,6,8")])


(define_insn "*andnothi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0")
		(not:HI (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
  ""
  "szc  %2, %0"
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:HI (not:HI (match_operand:HI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:HI 2 "nonimmediate_operand" "0,0,0,0")))]
  ""
  "szc  %1, %0"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------
(define_insn "andqi3"
  [(clobber (match_scratch:QI 3 "=r,r,r,r,r,r,r,r,r,r,r,r"))
   (set (match_operand:QI 0 "nonimmediate_operand" "=r,R>,Q,r,R>,Q,r,R>,Q,r,R>,Q")
	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0,0,0,0,0,0,0,0")
		(match_operand:QI 2 "general_operand" "r,r,r,R>,R>,R>,Q,Q,Q,i,i,i")))]
  ""
  {
    tms9900_debug_operands ("andqi3", operands, 3);
    int val;
    switch(which_alternative)
    {
    case 0:
      // output_asm_insn("mov  %2, %3", operands);
      // output_asm_insn("inv  %3", operands);
      // output_asm_insn("szc  %3, %0", operands);
      // break;
    case 1:
    case 2:
      // output_asm_insn("mov  %2, %3", operands);
      // output_asm_insn("inv  %3", operands);
      // output_asm_insn("swpb %3", operands);
      // output_asm_insn("szcb %3, %0", operands);
      // break;
    case 3:
    case 6:
      // output_asm_insn("movb %2, %3", operands);
      // output_asm_insn("srl  %3, 8", operands);
      // output_asm_insn("inv  %3", operands);
      // output_asm_insn("szc  %3, %0", operands);
      // break;
    case 4:
    case 5:
    case 7:
    case 8:
      output_asm_insn("movb %2, %3", operands);
      output_asm_insn("inv  %3", operands);
      output_asm_insn("szcb %3, %0", operands);
      break;
    case 9:
      val = INTVAL(operands[2]) & 0xFF00;
      /* AND const value and register */
      if(val == 0)
        output_asm_insn("clr  %0", operands);
      else if(val == 0xff00)
        return("");
      else
      {
        operands[2] = GEN_INT(val);
        output_asm_insn("andi %0, %2", operands);
      }
      break;
    case 10:
    case 11:
      val = INTVAL(operands[2]) & 0xFF00;
      /* AND const value and memory */
      if(val == 0)
        output_asm_insn("clr %0", operands);
      else if(val == 0xff00)
        return("");
      else
      {
        /*  In this case, we are putting a byte value to a memory location (R or
         *  Q) so we need the and mask to be in the MSB or register %3 */
        operands[2] = GEN_INT((~val)); // *256);
        output_asm_insn("li   %3, %2", operands);
        output_asm_insn("szcb %3, %0", operands);
      }
      break;
    }
    return("");
  }
  [(set_attr "length" "6,8,10,8,6,8,10,8,10,4,4,6")])


(define_insn "*andnotqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
		(not:QI (match_operand:QI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
  ""
  "szcb %2, %0"
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:QI (not:QI (match_operand:QI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:QI 2 "nonimmediate_operand" "0,0,0,0")))]
  ""
  "szcb %1, %0"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------------------------------------
;; Or


;;-------------------------------------
(define_insn "iorhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,r")
	(ior:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0,0,0,0,0")
		(match_operand:HI 2 "general_operand" "rR>,Q,rR>,Q,i,M")))]
  ""
  {
    tms9900_debug_operands ("iorhi3", operands, 3);
    if (GET_CODE (operands[2]) == CONST_INT)
      {
        int val = INTVAL(operands[2]) & 0xFFFF;
        if(val == 0xFFFF)
          return "seto %0";
        else if(val == 0)
          return "";
        else
          return "ori  %0, %2";
      }
    return "soc  %2, %0";
  }
  [(set_attr "length" "2,4,4,6,4,2")])


;;-------------------------------------
(define_insn "iorqi3"
   [(set (match_operand:QI 0 "nonimmediate_operand" "=r,R>,Q,r,R>,Q,r,R>,Q,r")
	(ior:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0,0,0,0,0,0")
		(match_operand:QI 2 "general_operand" "r,r,r,R>,R>,R>,Q,Q,Q,i")))]
  ""
  {
    tms9900_debug_operands ("iorqi3", operands, 3);
    int val;
    switch(which_alternative)
    {
    case 0:
      // output_asm_insn("soc  %2, %0", operands);
      // break;
    case 1:
    case 2:
      // output_asm_insn("swpb %2", operands);
      // output_asm_insn("socb %2, %0", operands);
      // output_asm_insn("swpb %2", operands);
      // break;
    case 3:
    case 6:
      // output_asm_insn("swpb %0", operands);
      // output_asm_insn("socb %3, %0", operands);
      // output_asm_insn("swpb %0", operands);
      // break;
    case 4:
    case 5:
    case 7:
    case 8:
      output_asm_insn("socb %3, %0", operands);
      break;
    case 9:
      val = INTVAL(operands[2]) & 0xFF00;
      /* AND const value and register */
      if(val == 0)
        return("");
      else if(val == 0xff00)
        // TODO this isn't valid if dest is a byte mem loc
        output_asm_insn("seto %0", operands);
      else
      {
        operands[2] = GEN_INT(val);
        output_asm_insn("ori  %0, %2", operands);
      }
      break;
    }
    return("");
  }
  [(set_attr "length" "2,6,8,6,2,4,6,2,4,4")])


;;-------------------------------------------------------------------
;; Xor


;;-------------------------------------
(define_insn "xorhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(xor:HI (match_operand:HI 1 "register_operand" "%0,0")
		(match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  "xor  %2, %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO respect byte boundaries for memory ops
(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(xor:QI (match_operand:QI 1 "register_operand" "%0,0")
		(match_operand:QI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  "xor  %2, %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Not


;;-------------------------------------
(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (not:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  "inv  %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO not safe for byte write to mem
(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q")
        (not:QI (match_operand:QI 1 "nonimmediate_operand" "0,0")))]
  ""
  "inv  %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;;  Arithmetic Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Add

;;-------------------------------------

;;-------------------------------------
(define_insn "addhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,r,rR>,Q")
	(plus:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0,0,0,0")
		 (match_operand:HI 2 "general_operand" "rR>LMNO,rR>LNMO,i,Q,Q")))]
  ""
  {
    tms9900_debug_operands ("addhi3", operands, 3);
    switch(GET_CODE(operands[2]))
    {
      case CONST_INT:
      {
        if (INTVAL(operands[2]) == 1)
	  return("inc  %0");
        else if (INTVAL(operands[2]) == -1)
          return("dec  %0");
        else if (INTVAL(operands[2]) == 2)
          return("inct %0");
        else if (INTVAL(operands[2]) == -2)
          return("dect %0");
        else
          return("ai   %0, %2");
      }

      case MEM:
      case REG:
        return ("a    %2, %0");

      default:
          return("ai   %0, %2");
    }
  }
  [(set_attr "length" "2,4,4,4,6")])


;;-------------------------------------
(define_insn "addqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r")
	(plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0,0,0")
		 (match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q,i")))]
  ""
  {
    tms9900_debug_operands ("addqi3", operands, 3);
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      operands[2] = GEN_INT(INTVAL(operands[2]) * 256);
      return("ai   %0, %2");
    }
  return("ab   %2, %0");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Subtract


;;-------------------------------------

;;-------------------------------------
(define_insn "subhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
	(minus:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
		  (match_operand:HI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))]
  ""
  {
    tms9900_debug_operands ("subhi3", operands, 3);
    if(which_alternative < 4)
    {
      output_asm_insn("s    %2, %0",operands);
    }
    else
    {
      output_asm_insn("s    %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------
(define_insn "*rsubihi"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(minus:HI (match_operand:HI 1 "immediate_operand" "i")
		  (match_operand:HI 2 "register_operand" "0")))]
  ""
  {
    if (INTVAL(operands[1]) == -1)
      output_asm_insn("inc  %0",operands);
    else if (INTVAL(operands[1]) == 1)
      output_asm_insn("dec  %0",operands);
    else if (INTVAL(operands[1]) == -2)
      output_asm_insn("inct %0",operands);
    else if (INTVAL(operands[1]) == 2)
      output_asm_insn("dect %0",operands);
    else
    {
      operands[1] = GEN_INT(-INTVAL(operands[1]));
      output_asm_insn("ai   %0, %1",operands);
    }
    output_asm_insn("neg  %0",operands);
    return "";
  }
  [(set_attr "length" "6")])


;;-------------------------------------
;; MGB TODO why negate?
(define_insn "subqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
	(minus:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
		  (match_operand:QI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))]
  ""
  {
    tms9900_debug_operands ("subqi3", operands, 3);
    if(which_alternative < 4)
    {
      output_asm_insn("sb   %2, %0",operands);
    }
    else
    {
      output_asm_insn("sb   %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------------------------------------
;; Multiply


;;-------------------------------------
;; (define_insn "umulhisi3"

(define_insn "mulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (match_operand:HI 1 "register_operand" "r,r")
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulhisi3", operands, 3);
    // tms9900_register_convert (operands[0], HImode, 1);
    // tms9900_register_convert (operands[1], HImode, 1);
    // tms9900_register_convert (operands[2], HImode, 1);

    // TODO can't emit a move here - we aren't an expand
    // emit_move_insn(operands[3],gen_rtx_ZERO_EXTEND(HImode, operands[1]));

    if(REG_P(operands[1]) && (REGNO(operands[1]) == REGNO(operands[0])))
    {
      /* op[1] == op[0], arguments in proper location */
      output_asm_insn("mpy  %2, %0", operands);
    }
    else
    {
      /* Arguments need to move */
      if(!REG_P(operands[2]) || (REGNO(operands[2]) != REGNO(operands[0])))
      {
        /* op[2] != op[0], fix that */
        output_asm_insn("mov  %2, %0", operands);
      }
      output_asm_insn("mpy  %1, %0", operands);
    }
    return("");
  }
  [(set_attr "length" "4,6")])

;;-------------------------------------
;;  MGB don't force 16-bit mult to be use 32-bit; it's overkill
;; TODO it isn't?  It should ref mulhisi3 above?  So why was it doing the long
;; mult above?  Might have been because I made it unsigned - red herring
;;-------------------------------------

;   (set (match_operand:HI 0 "register_operand" "=r,r")
;        (subreg:HI (match_dup 3) 2))]

;  MGB this expand is the first to be matched when doing a byte mul.  It seems
;  mult must take SI as mode so a match_dup is needed as first param because we
;  weren't passed any SI.

(define_expand "mulhi3"
  [(parallel [
     (clobber (match_scratch:SI 3 "+r,r"))
     (clobber (match_scratch:HI 4 "+r,r"))
     (clobber (match_scratch:HI 5 "+r,r"))
   (set (match_operand:HI 0 "register_operand" "=r,r")
        (mult:HI (match_operand:HI 1 "register_operand" "+0,0")
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))])]
  ""
  {
    tms9900_debug_operands ("mulhi3", operands, 3);

    #if 1
    operands[3] = gen_reg_rtx(SImode);
    operands[4] = gen_reg_rtx(HImode);
    operands[5] = gen_reg_rtx(HImode);

    /* Use temp for operands */
    emit_move_insn(operands[4], operands[1]);
    emit_move_insn(operands[5], operands[2]);
    emit_move_insn(operands[3],gen_rtx_ZERO_EXTEND(SImode, operands[0]));
    emit_insn(gen_mulhisi3(operands[3], operands[4], operands[5]));
    emit_move_insn (operands[0], gen_highpart (HImode, operands[3]));
    emit_move_insn(operands[1], operands[4]);
    emit_move_insn(operands[2], operands[5]);
    DONE;
    #endif
     // emit_move_insn(operands[3],gen_rtx_ZERO_EXTEND(SImode, operands[0]));
     // operands[3] = gen_rtx_ZERO_EXTEND(SImode, operands[0]);

     // ORIG:
     // operands[3] = force_reg(SImode, GEN_INT(0));

     // MGB NEW : try to copy udivmodhi4
     // rtx foo1, foo2;

     // Using these cause "unrecognisable insn"
      // foo1 = gen_rtx_ZERO_EXTEND(HImode, subreg:QI (operands[1], 0));
      // foo2 = gen_rtx_ZERO_EXTEND(HImode, subreg:QI (operands[2], 0));

     // foo1 = operands[1];
     // foo2 = operands[2];
     // rtx insn;
     // insn = emit_insn (gen_mulhisi3 (operands[3], foo1, foo2)); // operands[1], operands[2]));
     // insn = emit_insn (gen_mulhisi3 (operands[3], operands[4], operands[5]));
     // set_unique_reg_note (insn, REG_EQUAL, foo1);
     // set_unique_reg_note (insn, REG_EQUAL, foo2);
     // insn = emit_move_insn (operands[0], gen_highpart (HImode, operands[3]));
     // DONE;
   }
)

;;-------------------------------------
(define_insn "*mulqisi3"
  [
   (set (match_operand:SI 0 "register_operand" "=r")
        (mult:SI (match_operand:QI 1 "register_operand" "0")
                 (match_operand:QI 2 "register_operand" "r")))
  ]
  ""
  {
    tms9900_debug_operands ("mulqisi3", operands, 3);
    rtx ops[4];
    ops[0] = operands[0];  /* Destination */
    ops[1] = operands[1];  /* Source 1 */
    ops[2] = operands[2];  /* Source 2 */
    ops[3] = gen_rtx_REG (HImode, REGNO (operands[0]) + REGS_PER_WORD);  /* Low word of source */

    // Sometimes the source operands can get swapped, fix that here
    if(REGNO(operands[2]) != REGNO(operands[0]))
    {
      /* ops[2] != ops[0], fix that */
      output_asm_insn("mov  %2, %0", ops);
    }
    output_asm_insn("mpy  %1, %0", ops);
    output_asm_insn("mov  %0, %3", ops);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; MGB test byte mul.  Match byte operands but extend result to SI
;; [(set (sign_extend:SI (match_operand:QI 0 "register_operand" "=r,r,r"))
;;  [(set (match_operand:QI 0 "register_operand" "=r,r,r")
;;
;;  compiler doesn't like this insn.  Says not recognised.  Is it because I have
;; too many alternatives including immediates?  The mulhisi3 variant only allows
;; op0/1 to be registers.  Maybe leave it at reg and force the compiler to
;; figure out what to do with immeds.  Also Can we wrap the QI in a sign extend
;; or subreg?
;; Still happens with just regs
;; try mulqisi3 - doesn't match - gcc uses mulhisi3 instead
;; try moving higher? no point, regs are HI so this isn't matched for regs?

;; (define_insn "mulqisi3"
;;   [(set (match_operand:SI 0 "register_operand" "=r")
;;         (mult:SI (match_operand:QI 1 "register_operand" "r")
;;                  (match_operand:QI 2 "register_operand"  "r")))
;;    (clobber (match_scratch:HI 3 "+r"))]
;;   ""
;;   {
;;     output_asm_insn("movb %2, %3", operands);
;;     output_asm_insn("sra  %3, 8", operands);
;; 
;;     // output_asm_insn("movb %1, %4", operands);
;;     // output_asm_insn("sra  %4, 8", operands);
;;     output_asm_insn("sra  %1, 8", operands);
;; 
;;     output_asm_insn("mpy  %3, %1", operands);
;;     // output_asm_insn("sla  %4, 8", operands);
;;     // output_asm_insn("movb %4, %0", operands);
;;     // rtx ops[2];
;;     // ops[0] = gen_rtx_REG (HImode, REGNO (operands[4]+REGS_PER_WORD));
;;     // ops[1] = operands[0];
;;     // output_asm_insn("mov %0, %1", ops);
;;   }
;;   [(set_attr "length" "8")])

;;-------------------------------------------------------------------
;; Divide and Modulus


;;-------------------------------------
(define_insn "divmodsihi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (ior:SI
          (ashift:SI
            (zero_extend:SI
              (div:HI (match_operand:SI 1 "register_operand" "0,0")
                      (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
            (const_int 16))
          (zero_extend:SI 
            (mod:HI (match_dup 1)
                    (match_dup 2)))))]
  ""
  {
    tms9900_debug_operands ("divmodsihi3", operands, 3);
    tms9900_register_convert (operands[0], HImode, 1);
    tms9900_register_convert (operands[1], HImode, 1);
    tms9900_register_convert (operands[2], HImode, 1);
    output_asm_insn ("div  %2, %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


(define_expand "udivmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:SI 1 "register_operand" "+0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "+rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodhi4", operands, 4);
    rtx insn, div_equal, mod_equal, equal;
    /*  MGB TODO this expand generates a zero_extendqihi2 - HOW??  If this could be
     *  done for MUL as well then no need to track QI/HI modes of regs
     *
     *  I don't think it's done here.  It's matched somewhere else.
     */
    div_equal = gen_rtx_DIV (HImode, operands[1], operands[2]);
    mod_equal = gen_rtx_MOD (HImode, operands[1], operands[2]);
    equal = gen_rtx_IOR (SImode,
                         gen_rtx_ASHIFT (SImode,
                                         gen_rtx_ZERO_EXTEND (SImode, div_equal),
                                         GEN_INT (16)),
                         gen_rtx_ZERO_EXTEND (SImode, mod_equal));

    insn = emit_insn (gen_divmodsihi3 (operands[1], operands[1], operands[2]));
    set_unique_reg_note (insn, REG_EQUAL, equal);

    insn = emit_move_insn (operands[0], gen_highpart (HImode, operands[1]));
    set_unique_reg_note (insn, REG_EQUAL, mod_equal);

    insn = emit_move_insn (operands[3], gen_lowpart (HImode, operands[1]));
    set_unique_reg_note (insn, REG_EQUAL, div_equal);

    DONE;
  })


;;-------------------------------------
;; TODO - lots of scratch regs here
(define_expand "divmodhi4"
  [(parallel [
     (clobber (match_scratch:HI 4 "+r,r"))
     (clobber (match_scratch:HI 5 "+r,r"))
     (clobber (match_scratch:SI 6 "+r,r"))
     (clobber (match_scratch:HI 7 "+r,r"))
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))
])]
  ""
  {
    operands[4] = gen_reg_rtx(HImode);
    operands[5] = gen_reg_rtx(HImode); // tmp copy of mod sign not needed
    operands[6] = gen_reg_rtx(SImode);
    operands[7] = gen_reg_rtx(HImode);
    tms9900_debug_operands ("divmodhi4", operands, 8);
    tms9900_register_convert (operands[0], HImode, 1);
    tms9900_register_convert (operands[1], HImode, 1);
    tms9900_register_convert (operands[2], HImode, 1);
    tms9900_register_convert (operands[3], HImode, 1);

    // MGB The extendqihi2 insn is emitted right before these moves.  Does
    // creating temp HImodes cause emit of extend?  Try the same in mulhi3
    // expand

    /* Use temp for operands */
    emit_move_insn(operands[4], operands[1]);
    emit_move_insn(operands[5], operands[2]);

    /* Find quotient sign */
    emit_move_insn(operands[7], operands[1]);
    emit_insn(gen_xorhi3(operands[7], operands[7], operands[2]));
  
    /* Find modulus sign */
    // emit_move_insn(operands[5], operands[1]);

    /* Convert operands to absolute value */
    emit_insn(gen_abshi2(operands[4], operands[4]));
    emit_insn(gen_abshi2(operands[5], operands[5]));

    /* Perform division and modulus */
    emit_move_insn(operands[6],gen_rtx_ZERO_EXTEND(SImode, operands[7]));
    emit_insn(gen_udivmodhi4(operands[0], operands[6], operands[5], operands[3]));

    /* Correct sign of results */
    emit_insn(gen_divfixuphi2(operands[0], operands[7]));  /* Correct quotient sign */

    /* Mod is always positive, no need to change sign */
    // emit_insn(gen_divfixuphi2(operands[3], operands[5]));  /* Correct modulus sign */

    DONE;
  }
)


(define_insn "divfixuphi2"
  [(set (match_operand:HI 1 "register_operand" "=r")
        (not:HI (match_dup 1)))
   (set (match_operand:HI 0 "register_operand" "=r")
        (if_then_else:HI (lt:HI (match_dup 1) (const_int 0))
           (neg:HI (match_dup 0)) (match_dup 0)))]
  ""
  {
    tms9900_debug_operands ("divfixuphi2", operands, 2);
    tms9900_register_convert (operands[0], HImode, 1);
    tms9900_register_convert (operands[1], HImode, 1);
    output_asm_insn("inv  %1", operands);
    output_asm_insn("jlt  $+4", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Absolute Value


;;-------------------------------------
(define_insn "abshi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
	(abs:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("abshi2", operands, 2);
    tms9900_register_convert (operands[0], HImode, 1);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO not safe for byte operations, but limited to r onyl for now
;; TO do bytes would need to declare a scratch - maybe overkill
(define_insn "absqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(abs:QI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("absqi2", operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Negate


;;-------------------------------------
(define_insn "negsi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
	(neg:SI (match_operand:SI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("negsi2", operands, 2);
    rtx word[2];
    rtx offset[1];

    /* word 0 is most significant */
    word[0] = operands[0];
    if (REG_P (operands[0]))
    {
      word[1] = gen_rtx_REG(HImode, REGNO(operands[0]) + REGS_PER_WORD);
      offset[0] = GEN_INT(4);
    }
    else
    {
      word[1] = adjust_address(operands[0], HImode, 2);
      offset[0] = GEN_INT(6);
    }
    output_asm_insn("inv  %0", word);
    output_asm_insn("neg  %1", word);
    output_asm_insn("jnc  $+%0", offset);
    output_asm_insn("inc  %0", word);
    return("");
  }
  [(set_attr "length" "8,14")])


;;-------------------------------------
(define_insn "neghi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
	(neg:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("neghi2", operands, 2);
    // tms9900_register_convert (operands[0], HImode, 0);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO set LO not HI, what about R> and Q ?
(define_insn "negqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(neg:QI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("negqi2", operands, 2);
    output_asm_insn("andi %0, 0xFF00", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Other Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; No-op
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])



;;-------------------------------------------------------------------
;;  Optimizations For Comparisons
;;-------------------------------------------------------------------

;;-------------------------------------------------------------------
;; Optimization for X == {-2,-1,1,2}
(define_peephole2
  [(set (reg:CC CC_REGNUM)
	(compare:CC (match_operand:HI 0 "register_operand" "")
		 (match_operand:HI 1 "immediate_operand" "")))
   (set (pc) (if_then_else (eq (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 2 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_dup 0) (neg:HI (match_dup 1))))
   (set (reg:CC CC_REGNUM) (match_dup 0))
   (set (pc) (if_then_else (eq (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 2))
                           (pc)))]
  )


(define_insn "*sub_const_hi"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (plus:HI (match_operand:HI 1 "register_operand" "0,0")
                 (neg:HI (match_operand:HI 2 "immediate_operand" "LMNO, i"))))]
  ""
  {
    operands[2] = GEN_INT(-INTVAL(operands[2]));
    switch(INTVAL(operands[2]))
    {
      case -2: output_asm_insn("dect %0",     operands); break;
      case -1: output_asm_insn("dec  %0",     operands); break;
      case  1: output_asm_insn("inc  %0",     operands); break;
      case  2: output_asm_insn("inct %0",     operands); break;
      default: output_asm_insn("ai   %0, %2", operands); break;
    }
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Optimization for X != {-2,-1,1,2}
(define_peephole2
  [(set (reg:CC CC_REGNUM)
	(compare:CC (match_operand:HI 0 "register_operand" "")
		 (match_operand:HI 1 "immediate_operand" "")))
   (set (pc) (if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 2 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_dup 0) (neg:HI (match_dup 1))))
   (set (reg:CC CC_REGNUM) (match_dup 0))
   (set (pc) (if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 2))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;;  Optimizations For Byte Compares
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (gtu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (gtu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )

;; TODO assume this can be deleted
(define_insn "*cmpqi_as_hi"
  [(set (reg:CC CC_REGNUM)
      (compare:CC (match_operand:QI 0 "register_operand" "r")
         (plus:HI (match_operand:HI 1 "const_int_operand" "i")
            (mult:HI (match_operand:HI 2 "const_int_operand" "i")
               (match_operand:HI 3 "const_int_operand" "i")))))]
  "INTVAL(operands[3]) == 256 && (INTVAL(operands[1]) == 0 || INTVAL(operands[1]) == 255)"
  {
    operands[1] = GEN_INT(INTVAL(operands[2]) * 256 + INTVAL(operands[1]));
    return("ci   %0, %1");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (ltu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ltu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (geu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (geu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (leu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (leu (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (gt (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                  (const_int 256)))))
   (set (pc) (if_then_else (gt (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (lt (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (lt (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (ge (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ge (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (reg:CC CC_REGNUM)
        (compare:CC (match_operand:QI 2 "register_operand" "")
                 (match_dup 0)))
   (set (pc) (if_then_else (le (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (reg:CC CC_REGNUM)
        (compare:CC (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (le (reg:CC CC_REGNUM) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;;  Optimizations For Bit Shift And Cast
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (ashiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "")))
   (set (match_operand:QI 2 "register_operand" "")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  )

(define_insn "*ashiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("sra  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X = (unsigned int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (lshiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "")))
   (set (match_operand:QI 2 "register_operand" "")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_insn "*lshiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("srl  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (ashift:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "")))
   (set (match_operand:QI 2 "register_operand" "")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashift:HI (match_dup 0)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_insn "*ashift_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashift:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    operands[1] = GEN_INT(8 + INTVAL (operands[1]));
    output_asm_insn("sla  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (char X) >> N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (ashiftrt:QI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "")))
   (set (match_operand:HI 2 "register_operand" "")
        (sign_extend:HI (match_dup 0)))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI (match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 2 "register_operand" "")
        (ashiftrt:HI (match_dup 2)
            (match_operand:HI 3 "const_int_operand" "")))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 3) 
                      (const_int 8))))]
  )


(define_insn "*ashiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("sra  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (unsigned char X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (lshiftrt:HI (match_operand:HI 1 "register_operand" "")
            (match_operand:HI 2 "const_int_operand" "")))
   (set (match_operand:HI 3 "register_operand" "")
        (and:HI (match_operand:HI 4 "const_int_operand" "")
                (match_operand:HI 5 "const_int_operand" "")))]
  "(REGNO(operands[0]) == REGNO(operands[3])) && (INTVAL(operands[5]) == (1<<(8-INTVAL(operands[2])))-1)"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_dup 2) 
                      (const_int 8))))]
  )


(define_insn "*lshiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("srl  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = ((int)(char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (sign_extend:HI (match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 3 "register_operand" "")
        (ashift:HI (match_operand:HI 4 "register_operand" "")
                   (match_operand:HI 5 "const_int_operand" "")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (ashiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  )

(define_insn "*qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL(operands[3]);
    if(shift == 0) {
      output_asm_insn("swpb %0", operands);
      }
    else if(shift >= 1 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("sra  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0x00FF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned int)X = ((unsigned int)(unsigned char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (zero_extend:HI (match_operand:QI 1 "register_operand" "")))
   (set (match_operand:HI 3 "register_operand" "")
        (ashift:HI (match_operand:HI 4 "register_operand" "")
                   (match_operand:HI 5 "const_int_operand" "")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (lshiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  )


(define_insn "*unsigned_qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL(operands[3]);
    if(shift >= 0 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("srl  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0xFFFF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned long)X = (unsigned long Y) >> 16
;;   Original code:
;;     mov  r3, r6
;;     mov  r4, r7
;;     mov  r6, r7
;;     clr  r6
;;
;;   Optimized:
;;     mov r3, r7
;;     clr r6
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "register_operand" ""))
   (set (match_operand:HI 2 "register_operand" "")
        (match_operand:HI 3 "register_operand" ""))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" ""))
    (set (match_operand:SI 5 "register_operand" "")
         (lshiftrt:SI (match_operand:SI 6 "register_operand" "")
                      (match_operand:HI 7 "const_int_operand" "")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 2) (match_dup 1))
   (set (match_dup 0) (const_int 0))]
)


(define_insn "*set_consthi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "const_int_operand" "i"))]
  ""
  {
    if(INTVAL(operands[1]) == 0) {
      output_asm_insn("clr  %0", operands);
    } else if((INTVAL(operands[1]) & 0xFFFF) == 0xFFFF) {
      output_asm_insn("seto  %0", operands);
    } else {
      output_asm_insn("li   %0, %1", operands);
    }
    return("");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for X = Y << 16
;;   Original code:
;;     mov  r4, r6
;;     mov  r5, r7
;;     mov  r7, r6
;;     clr  r7
;;
;;   Optimized:
;;     mov r5, r6
;;     clr r7
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "register_operand" ""))
   (set (match_operand:HI 2 "register_operand" "")
        (match_operand:HI 3 "register_operand" ""))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" ""))
    (set (match_operand:SI 5 "register_operand" "")
         (ashift:SI (match_operand:SI 6 "register_operand" "")
                      (match_operand:HI 7 "const_int_operand" "")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 0) (match_dup 3))
   (set (match_dup 2) (const_int 0))]
)


;-------------------------------------------------------------------
;; Optimization for byte array initializations
; This handles sequences like:
;   li   r1, >1200
;   movb r1, *r2
;   li   r1, >3400
;   movb r1, @1(r2)
;
; and converts to:
;   li   r1, >1234
;   movb r1, *r2
;   swpb r1
;   movb r1, @1(r2)
;
; This saves two bytes and is slightly faster
(define_peephole2
  [(match_scratch:HI 6 "")
   (set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "const_int_operand" ""))
   (set (match_operand:QI 2 "nonimmediate_operand" "")
        (match_dup 0))
   (set (match_operand:QI 3 "register_operand" "")
        (match_operand:QI 4 "const_int_operand" ""))
   (set (match_operand:QI 5 "nonimmediate_operand" "")
        (match_dup 3))]
  "peep2_reg_dead_p(4, operands[0]) && peep2_reg_dead_p(4, operands[3])"
  [(set (match_dup 6)
        (ior:HI (ashift:HI (match_dup 1) 
                     (const_int 8))
             (match_dup 4)))
   (set (match_dup 2)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 8)) 1))
   (set (match_dup 5)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 0)) 1))]
)


(define_insn "*movhi_combine_consts"
  [(set (match_operand:HI 0 "register_operand" "")
        (ior:HI (ashift:HI (match_operand:QI 1 "const_int_operand" "")
                           (match_operand:QI 2 "const_int_operand" ""))
                (match_operand:QI 3 "const_int_operand" "")))]
  ""
  {
    operands[1] = GEN_INT(((INTVAL(operands[1]) & 0xFF) << 8) |
                           (INTVAL(operands[3]) & 0xFF));
    return "li   %0, %1";
  }
  [(set_attr "length" "4")])


(define_insn "*movqi_for_initializer"
  [(set (match_operand:QI 0 "memory_operand" "=rR>,Q")
        (subreg:QI (ashiftrt:HI (match_operand:HI 1 "register_operand" "r,r")
                              (match_operand:HI 2 "const_int_operand" "i,i")) 1))]
  ""
  {
    if(INTVAL(operands[2]) == 8)
    {
      output_asm_insn("movb %1, %0", operands);
    }
    else if(INTVAL(operands[2]) == 0)
    {
      output_asm_insn("swpb %1", operands);
      output_asm_insn("movb %1, %0", operands);
    }
   return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Optimization for memory-to-memory copies
;; Combine a mem-reg-mem copy into a mem-mem copy
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "memory_operand" ""))
   (set (match_operand:HI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 2 "memory_operand" "")
        (match_operand:HI 1 "memory_operand" ""))]
)

   
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "memory_operand" ""))
   (set (match_operand:QI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:QI 2 "memory_operand" "")
        (match_operand:QI 1 "memory_operand" ""))]
)


;;-------------------------------------------------------------------
;; Optimization for (int)X = (unsigned char)((int)X)
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (subreg:QI (match_operand:HI 1 "register_operand") 1))
   (set (match_operand:HI 2 "register_operand" "")
        (zero_extend:HI (match_dup 0)))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (match_dup 1))
   (set (match_dup 2)
        (and:HI (match_dup 2) (const_int 255)))]
)

(define_insn "*andi_const"
  [(set (match_operand:HI 0 "register_operand" "")
        (and:HI (match_dup 0)
                (match_operand:HI 1 "const_int_operand" "")))]
  ""
  {
    int val = INTVAL(operands[1]) & 0xFFFF;
    if(val == 0)
      return "clr  %0";
    else if(val == 0xFFFF)
      return "";
    else
      return "andi %0, %1";
  }
  [(set_attr "length" "4")])

